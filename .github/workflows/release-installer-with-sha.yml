name: Release - Build & Upload Installer with SHA256

on:
  workflow_dispatch:
    inputs:
      tag:
        description: 'Release tag (e.g., v1.12.0) - leave empty to use latest'
        required: false

concurrency:
  group: release-installer-${{ github.event.inputs.tag || github.run_id }}
  cancel-in-progress: true

permissions:
  contents: write

jobs:
  release-installer:
    runs-on: windows-latest
    name: Build & Upload Installer with SHA256
    outputs:
      tag: ${{ steps.resolve_tag.outputs.tag }}
      version: ${{ steps.resolve_tag.outputs.version }}
      release_id: ${{ steps.resolve_tag.outputs.release_id }}
      sha256: ${{ steps.hash.outputs.sha256 }}
      size: ${{ steps.hash.outputs.size }}
      path: ${{ steps.hash.outputs.path }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.ref }}

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install Inno Setup 6
        shell: pwsh
        run: |
          choco install innosetup -y --no-progress
          $paths = @(
            "C:\\Program Files (x86)\\Inno Setup 6",
            "C:\\Program Files\\Inno Setup 6",
            "$env:LOCALAPPDATA\Programs\Inno Setup 6"
          )
          foreach ($p in $paths) {
            if (Test-Path $p) {
              Write-Host "Inno Setup installed at $p"
              $env:PATH += ";$p"
              break
            }
          }

      - name: Resolve release tag
        id: resolve_tag
        shell: pwsh
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          $ErrorActionPreference = 'Stop'
          $tag = ""
          $releaseId = ""

          if ("${{ github.event.inputs.tag }}" -ne "") {
            # Manual dispatch with explicit tag
            $tag = "${{ github.event.inputs.tag }}"
            Write-Host "Manual dispatch with tag: $tag"
          } else {
            # No tag provided: get the latest release
            Write-Host "No tag specified, fetching latest release..."
            try {
              $latest = gh release view --json tagName,id -q '.tagName,.id'
              if ($LASTEXITCODE -eq 0 -and $latest) {
                $lines = $latest -split "`n"
                $tag = $lines[0]
                $releaseId = $lines[1]
                Write-Host "Latest release: $tag (ID: $releaseId)"
              } else {
                Write-Error "No releases found. Please provide a tag."
                exit 1
              }
            } catch {
              Write-Error "Failed to fetch latest release"
              exit 1
            }
          }

          if ([string]::IsNullOrEmpty($tag)) {
            Write-Error "Could not determine release tag"
            exit 1
          }

          if ($tag -notmatch '^v\d+\.\d+\.\d+$') {
            Write-Error "Resolved tag '$tag' is not in required format vMAJOR.MINOR.PATCH"
            exit 1
          }

          # Strict mode: the release must already exist for this tag
          try {
            $releaseId = (gh release view $tag --json id -q .id).Trim()
          } catch {
            Write-Error "Release for tag '$tag' was not found. Aborting installer upload to prevent lineage drift."
            exit 1
          }

          if ([string]::IsNullOrEmpty($releaseId)) {
            Write-Error "Release ID for tag '$tag' is empty. Aborting."
            exit 1
          }

          Write-Host "Release verified for $tag (ID: $releaseId)"

          echo "tag=$tag" >> $env:GITHUB_OUTPUT
          echo "release_id=$releaseId" >> $env:GITHUB_OUTPUT
          echo "version=$($tag -replace '^v', '')" >> $env:GITHUB_OUTPUT

      - name: Validate checkout matches tag version
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $tag = "${{ steps.resolve_tag.outputs.tag }}"
          $expectedVersion = "${{ steps.resolve_tag.outputs.version }}"
          $versionFile = (Get-Content VERSION -Raw).Trim()

          Write-Host "Tag: $tag"
          Write-Host "Expected version from tag: $expectedVersion"
          Write-Host "VERSION file in checked out ref: $versionFile"

          if ($versionFile -ne $expectedVersion) {
            Write-Error "Tag/version mismatch: tag '$tag' implies '$expectedVersion' but VERSION file is '$versionFile'."
            exit 1
          }

      - name: Clean dist before build
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          if (Test-Path "dist") {
            Write-Host "Cleaning existing dist artifacts to prevent stale installer pickup..."
            Get-ChildItem "dist" -File -ErrorAction SilentlyContinue | Remove-Item -Force -ErrorAction SilentlyContinue
          }
          New-Item -ItemType Directory -Path "dist" -Force | Out-Null

      - name: Import code signing certificate (from secrets)
        id: import_cert
        shell: pwsh
        env:
          CODESIGN_PFX_BASE64: ${{ secrets.CODESIGN_PFX_BASE64 }}
          CODESIGN_PFX_PASSWORD: ${{ secrets.CODESIGN_PFX_PASSWORD }}
        run: |
          $ErrorActionPreference = 'Stop'
          if (-not $env:CODESIGN_PFX_BASE64 -or -not $env:CODESIGN_PFX_PASSWORD) {
            Write-Host "Code signing certificate secrets not provided. Skipping import (signing will be skipped)."
            exit 0
          }

          $pfxPath = Join-Path $env:RUNNER_TEMP "sms_codesign.pfx"
          [IO.File]::WriteAllBytes($pfxPath, [Convert]::FromBase64String($env:CODESIGN_PFX_BASE64))

          $securePassword = ConvertTo-SecureString $env:CODESIGN_PFX_PASSWORD -AsPlainText -Force
          Import-PfxCertificate -FilePath $pfxPath -CertStoreLocation "Cert:\CurrentUser\My" -Password $securePassword | Out-Null

          "pfx_path=$pfxPath" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          Write-Host "Code signing certificate imported to CurrentUser store."

      - name: Verify version consistency
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          Write-Host "Verifying version consistency across all files..."
          $tag = "${{ steps.resolve_tag.outputs.tag }}"
          $version = "${{ steps.resolve_tag.outputs.version }}"

          Write-Host "Expected version: $version (from tag: $tag)"

          if (Test-Path ".\scripts\VERIFY_VERSION.ps1") {
            Write-Host "Running VERIFY_VERSION.ps1 in CI mode..."
            & ".\scripts\VERIFY_VERSION.ps1" -CIMode
            if ($LASTEXITCODE -ne 0) {
              Write-Warning "Version verification found issues, but continuing (may cause issues in release)"
            }
            Write-Host "Version verification check completed"
          } else {
            Write-Warning "Version verification script not found, skipping..."
          }

      - name: Build installer
        shell: pwsh
        env:
          SMS_CODESIGN_PFX_PATH: ${{ steps.import_cert.outputs.pfx_path }}
          SMS_CODESIGN_PFX_PASSWORD: ${{ secrets.CODESIGN_PFX_PASSWORD }}
        run: |
          $ErrorActionPreference = 'Stop'
          Write-Host "Building installer for version ${{ steps.resolve_tag.outputs.version }}..."
          & ".\INSTALLER_BUILDER.ps1" -AutoFix -Verbose
          if ($LASTEXITCODE -ne 0) {
            Write-Error "Installer build failed"
            exit 1
          }
          Write-Host "Installer build completed successfully"

      - name: Verify installer exists
        id: verify_installer
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $version = "${{ steps.resolve_tag.outputs.version }}"
          $expectedPath = "dist\SMS_Installer_${version}.exe"

          Write-Host "=== Installer Verification (strict) ==="
          Write-Host "Version: $version"
          Write-Host "Current directory: $(Get-Location)"
          Write-Host "Expected installer path: $expectedPath"
          Write-Host ""

          # Show what actually exists in dist/
          Write-Host "Contents of dist/ directory:"
          if (Test-Path "dist") {
            Get-ChildItem "dist" -Filter "*.exe" | ForEach-Object {
              Write-Host "  - $($_.Name) ($([math]::Round($_.Length/1MB, 2)) MB)"
            }
          } else {
            Write-Host "  dist/ directory does not exist!"
          }
          Write-Host ""

          if (-not (Test-Path $expectedPath)) {
            Write-Error "Expected installer not found: $expectedPath"
            exit 1
          }

          Write-Host "✓ Found expected installer: $expectedPath"
          echo "path=$expectedPath" >> $env:GITHUB_OUTPUT

      - name: Calculate SHA256 hash
        id: hash
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $installer = "${{ steps.verify_installer.outputs.path }}"

          if (-not (Test-Path $installer)) {
            Write-Error "Installer not found at: $installer"
            exit 1
          }

          $hash = (Get-FileHash $installer -Algorithm SHA256).Hash
          $fileSize = (Get-Item $installer).Length
          $fileSizeMB = [math]::Round($fileSize / 1MB, 2)
          echo "sha256=$hash" >> $env:GITHUB_OUTPUT
          echo "size=$fileSizeMB" >> $env:GITHUB_OUTPUT
          echo "path=$installer" >> $env:GITHUB_OUTPUT
          Write-Host "File: $installer"
          Write-Host "Size: $fileSizeMB MB"
          Write-Host "SHA256: $hash"

      - name: Validate installer payload size (guardrail)
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $installerPath = "${{ steps.hash.outputs.path }}"
          if (-not (Test-Path $installerPath)) {
            Write-Error "Installer path not found for payload validation: $installerPath"
            exit 1
          }

          $sizeBytes = (Get-Item $installerPath).Length
          $sizeMB = [math]::Round($sizeBytes / 1MB, 2)
          $minSizeBytes = 20000000  # 20 MB minimum expected payload size

          Write-Host "Installer size bytes: $sizeBytes"
          Write-Host "Installer size MB: $sizeMB"
          Write-Host "Minimum expected bytes: $minSizeBytes"

          if ($sizeBytes -lt $minSizeBytes) {
            Write-Error "Installer payload is unexpectedly small ($sizeMB MB). Blocking release asset overwrite to prevent publishing a broken installer."
            exit 1
          }

          Write-Host "✓ Installer payload size check passed"

      - name: Upload installer to release
        if: steps.hash.outputs.path != ''
        shell: pwsh
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          $ErrorActionPreference = 'Stop'
          function Invoke-GhChecked {
            param([string[]]$Arguments)
            & gh @Arguments
            if ($LASTEXITCODE -ne 0) {
              throw "gh command failed: gh $($Arguments -join ' ')"
            }
          }

          function Invoke-GhJsonChecked {
            param([string[]]$Arguments)
            $output = & gh @Arguments
            if ($LASTEXITCODE -ne 0) {
              throw "gh command failed: gh $($Arguments -join ' ')"
            }
            return $output
          }

          $installerPath = "${{ steps.hash.outputs.path }}"
          $tag = "${{ steps.resolve_tag.outputs.tag }}"
          $version = "${{ steps.resolve_tag.outputs.version }}"
          $assetName = "SMS_Installer_${version}.exe"
          $repo = "${{ github.repository }}"
          $localHash = (Get-FileHash $installerPath -Algorithm SHA256).Hash.ToLowerInvariant()
          $localDigest = "sha256:$localHash"

          Write-Host "Uploading $assetName to release..."
          Write-Host "Tag: $tag"
          Write-Host "Installer path: $installerPath"
          Write-Host "Asset name: $assetName"
          Write-Host "Local digest: $localDigest"

          try {
            $release = (Invoke-GhJsonChecked @("release", "view", $tag, "--repo", $repo, "--json", "assets")) | ConvertFrom-Json
            $existing = $release.assets | Where-Object { $_.name -eq $assetName } | Select-Object -First 1

            if ($existing) {
              Write-Host "Existing asset detected: $($existing.name) (digest: $($existing.digest))"
              if ($existing.digest -eq $localDigest) {
                Write-Host "✓ Release installer already up-to-date; skipping upload"
                exit 0
              }

              Write-Host "Digest differs; replacing existing asset safely (delete + upload)"
              Invoke-GhChecked @("release", "delete-asset", $tag, $assetName, "--yes", "--repo", $repo)
            }

            Invoke-GhChecked @("release", "upload", $tag, "$installerPath#$assetName", "--repo", $repo)
            Write-Host "✓ Successfully uploaded installer to release $tag (digest: $localDigest)"
          } catch {
            Write-Error "Failed to upload installer to release: $($_.Exception.Message)"
            exit 1
          }

      - name: Upload SHA256 sidecar asset
        if: steps.hash.outputs.path != ''
        shell: pwsh
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          $ErrorActionPreference = 'Stop'
          function Invoke-GhChecked {
            param([string[]]$Arguments)
            & gh @Arguments
            if ($LASTEXITCODE -ne 0) {
              throw "gh command failed: gh $($Arguments -join ' ')"
            }
          }

          function Invoke-GhJsonChecked {
            param([string[]]$Arguments)
            $output = & gh @Arguments
            if ($LASTEXITCODE -ne 0) {
              throw "gh command failed: gh $($Arguments -join ' ')"
            }
            return $output
          }

          $tag = "${{ steps.resolve_tag.outputs.tag }}"
          $version = "${{ steps.resolve_tag.outputs.version }}"
          $repo = "${{ github.repository }}"
          $assetName = "SMS_Installer_${version}.exe.sha256"
          $sha = "${{ steps.hash.outputs.sha256 }}".Trim()
          $line = "$sha  SMS_Installer_${version}.exe"
          $shaPath = Join-Path $env:RUNNER_TEMP $assetName
          Set-Content -Path $shaPath -Value $line -NoNewline

          try {
            $release = (Invoke-GhJsonChecked @("release", "view", $tag, "--repo", $repo, "--json", "assets")) | ConvertFrom-Json
            $existing = $release.assets | Where-Object { $_.name -eq $assetName } | Select-Object -First 1
            if ($existing) {
              Invoke-GhChecked @("release", "delete-asset", $tag, $assetName, "--yes", "--repo", $repo)
            }

            Invoke-GhChecked @("release", "upload", $tag, "$shaPath#$assetName", "--repo", $repo)
            Write-Host "✓ Uploaded SHA256 sidecar asset: $assetName"
          } catch {
            Write-Error "Failed to upload SHA256 sidecar: $($_.Exception.Message)"
            exit 1
          }

      - name: Enforce installer-only release assets (cleanup)
        if: steps.hash.outputs.path != ''
        shell: pwsh
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          $ErrorActionPreference = 'Stop'
          function Invoke-GhChecked {
            param([string[]]$Arguments)
            & gh @Arguments
            if ($LASTEXITCODE -ne 0) {
              throw "gh command failed: gh $($Arguments -join ' ')"
            }
          }

          function Invoke-GhJsonChecked {
            param([string[]]$Arguments)
            $output = & gh @Arguments
            if ($LASTEXITCODE -ne 0) {
              throw "gh command failed: gh $($Arguments -join ' ')"
            }
            return $output
          }

          $tag = "${{ steps.resolve_tag.outputs.tag }}"
          $version = "${{ steps.resolve_tag.outputs.version }}"
          $repo = "${{ github.repository }}"

          $allowed = @(
            "SMS_Installer_${version}.exe",
            "SMS_Installer_${version}.exe.sha256"
          )

          $release = (Invoke-GhJsonChecked @("release", "view", $tag, "--repo", $repo, "--json", "assets")) | ConvertFrom-Json
          $assets = @($release.assets)

          if (-not $assets -or $assets.Count -eq 0) {
            Write-Warning "Release has no assets to evaluate."
            exit 0
          }

          $removed = 0
          foreach ($asset in $assets) {
            if ($allowed -contains $asset.name) {
              continue
            }

            Write-Host "Removing non-allowlisted release asset: $($asset.name)"
            Invoke-GhChecked @("release", "delete-asset", $tag, $asset.name, "--yes", "--repo", $repo)
            $removed++
          }

          if ($removed -gt 0) {
            Write-Host "✓ Removed $removed non-allowlisted asset(s) from release $tag"
          } else {
            Write-Host "✓ Release assets already comply with installer-only allowlist"
          }

      - name: Verify installer-only release assets (final gate)
        if: steps.hash.outputs.path != ''
        shell: pwsh
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          $ErrorActionPreference = 'Stop'
          function Invoke-GhJsonChecked {
            param([string[]]$Arguments)
            $output = & gh @Arguments
            if ($LASTEXITCODE -ne 0) {
              throw "gh command failed: gh $($Arguments -join ' ')"
            }
            return $output
          }

          $tag = "${{ steps.resolve_tag.outputs.tag }}"
          $version = "${{ steps.resolve_tag.outputs.version }}"
          $repo = "${{ github.repository }}"

          $allowed = @(
            "SMS_Installer_${version}.exe",
            "SMS_Installer_${version}.exe.sha256"
          )

          $release = (Invoke-GhJsonChecked @("release", "view", $tag, "--repo", $repo, "--json", "assets")) | ConvertFrom-Json
          $assets = @($release.assets)
          $unexpected = @($assets | Where-Object { $allowed -notcontains $_.name })

          if ($unexpected.Count -gt 0) {
            Write-Error "Release asset allowlist check failed after cleanup. Unexpected assets remain:"
            foreach ($asset in $unexpected) {
              Write-Error " - $($asset.name)"
            }
            exit 1
          }

          Write-Host "✓ Final release asset gate passed (installer-only allowlist)"

      - name: Create release summary
        shell: pwsh
        run: |
          $tag = "${{ steps.resolve_tag.outputs.tag }}"
          $version = "${{ steps.resolve_tag.outputs.version }}"
          $sha256 = "${{ steps.hash.outputs.sha256 }}"
          $size = "${{ steps.hash.outputs.size }}"

          $summary = @"
          ## Release $tag - Installer Built

          **Installer**: SMS_Installer_${version}.exe
          **Version**: ${version}
          **Size**: ${size} MB
          **SHA256**: ${sha256}

          ### Verify Installer Integrity

          PowerShell:
          \`\`\`powershell
          (Get-FileHash 'SMS_Installer_${version}.exe' -Algorithm SHA256).Hash
          \`\`\`

          Expected SHA256:
          \`${sha256}\`

          The installer is available as a release asset.
          "@

          Add-Content -Path $env:GITHUB_STEP_SUMMARY -Value $summary

      - name: Post success notification
        if: success()
        run: |
          Write-Host "✓ Release workflow completed successfully"
          Write-Host "  - Tag: ${{ steps.resolve_tag.outputs.tag }}"
          Write-Host "  - Version: ${{ steps.resolve_tag.outputs.version }}"
          Write-Host "  - Installer: SMS_Installer_${{ steps.resolve_tag.outputs.version }}.exe"
          Write-Host "  - Size: ${{ steps.hash.outputs.size }} MB"
          Write-Host "  - SHA256: ${{ steps.hash.outputs.sha256 }}"
        shell: pwsh

  notify-failure:
    runs-on: ubuntu-latest
    needs: release-installer
    if: failure()
    name: Release Failure Notification

    steps:
      - name: Notify failure
        run: |
          echo "❌ Release workflow failed - check logs for details"
          echo "Tag: ${{ needs.release-installer.outputs.tag }}"
