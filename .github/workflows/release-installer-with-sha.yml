name: Release - Build & Upload Installer with SHA256

on:
  workflow_dispatch:
    inputs:
      tag:
        description: 'Release tag (e.g., v1.12.0) - leave empty to use latest'
        required: false

concurrency:
  group: release-installer-${{ github.event.inputs.tag || github.run_id }}
  cancel-in-progress: true

jobs:
  release-installer:
    runs-on: windows-latest
    name: Build & Upload Installer with SHA256
    outputs:
      tag: ${{ steps.resolve_tag.outputs.tag }}
      version: ${{ steps.resolve_tag.outputs.version }}
      release_id: ${{ steps.resolve_tag.outputs.release_id }}
      sha256: ${{ steps.hash.outputs.sha256 }}
      size: ${{ steps.hash.outputs.size }}
      path: ${{ steps.hash.outputs.path }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install Inno Setup 6
        shell: pwsh
        run: |
          choco install innosetup -y --no-progress
          $paths = @(
            "C:\\Program Files (x86)\\Inno Setup 6",
            "C:\\Program Files\\Inno Setup 6",
            "$env:LOCALAPPDATA\Programs\Inno Setup 6"
          )
          foreach ($p in $paths) {
            if (Test-Path $p) {
              Write-Host "Inno Setup installed at $p"
              $env:PATH += ";$p"
              break
            }
          }

      - name: Resolve release tag
        id: resolve_tag
        shell: pwsh
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          $tag = ""
          $releaseId = ""

          if ("${{ github.event.inputs.tag }}" -ne "") {
            # Manual dispatch with explicit tag
            $tag = "${{ github.event.inputs.tag }}"
            Write-Host "Manual dispatch with tag: $tag"
            # Fetch the release ID for this tag
            try {
              $release = gh release view $tag --json id -q .id 2>$null
              if ($LASTEXITCODE -eq 0 -and $release) {
                $releaseId = $release
                Write-Host "Found release ID: $releaseId"
              } else {
                Write-Host "No release found for tag $tag yet (will be created if needed)"
              }
            } catch {
              Write-Host "Could not fetch release ID, will attempt upload anyway"
            }
          } else {
            # No tag provided: get the latest release
            Write-Host "No tag specified, fetching latest release..."
            try {
              $latest = gh release view --json tagName,id -q '.tagName,.id'
              if ($LASTEXITCODE -eq 0 -and $latest) {
                $lines = $latest -split "`n"
                $tag = $lines[0]
                $releaseId = $lines[1]
                Write-Host "Latest release: $tag (ID: $releaseId)"
              } else {
                Write-Error "No releases found. Please provide a tag."
                exit 1
              }
            } catch {
              Write-Error "Failed to fetch latest release"
              exit 1
            }
          }

          if ([string]::IsNullOrEmpty($tag)) {
            Write-Error "Could not determine release tag"
            exit 1
          }

          echo "tag=$tag" >> $env:GITHUB_OUTPUT
          echo "release_id=$releaseId" >> $env:GITHUB_OUTPUT
          echo "version=$($tag -replace '^v', '')" >> $env:GITHUB_OUTPUT

      - name: Import code signing certificate (from secrets)
        id: import_cert
        shell: pwsh
        env:
          CODESIGN_PFX_BASE64: ${{ secrets.CODESIGN_PFX_BASE64 }}
          CODESIGN_PFX_PASSWORD: ${{ secrets.CODESIGN_PFX_PASSWORD }}
        run: |
          $ErrorActionPreference = 'Stop'
          if (-not $env:CODESIGN_PFX_BASE64 -or -not $env:CODESIGN_PFX_PASSWORD) {
            Write-Host "Code signing certificate secrets not provided. Skipping import (signing will be skipped)."
            exit 0
          }

          $pfxPath = Join-Path $env:RUNNER_TEMP "sms_codesign.pfx"
          [IO.File]::WriteAllBytes($pfxPath, [Convert]::FromBase64String($env:CODESIGN_PFX_BASE64))

          $securePassword = ConvertTo-SecureString $env:CODESIGN_PFX_PASSWORD -AsPlainText -Force
          Import-PfxCertificate -FilePath $pfxPath -CertStoreLocation "Cert:\CurrentUser\My" -Password $securePassword | Out-Null

          "pfx_path=$pfxPath" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          Write-Host "Code signing certificate imported to CurrentUser store."

      - name: Verify version consistency
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          Write-Host "Verifying version consistency across all files..."
          $tag = "${{ steps.resolve_tag.outputs.tag }}"
          $version = "${{ steps.resolve_tag.outputs.version }}"

          Write-Host "Expected version: $version (from tag: $tag)"

          if (Test-Path ".\scripts\VERIFY_VERSION.ps1") {
            Write-Host "Running VERIFY_VERSION.ps1 in CI mode..."
            & ".\scripts\VERIFY_VERSION.ps1" -CIMode
            if ($LASTEXITCODE -ne 0) {
              Write-Warning "Version verification found issues, but continuing (may cause issues in release)"
            }
            Write-Host "Version verification check completed"
          } else {
            Write-Warning "Version verification script not found, skipping..."
          }

      - name: Build installer
        shell: pwsh
        env:
          SMS_CODESIGN_PFX_PATH: ${{ steps.import_cert.outputs.pfx_path }}
          SMS_CODESIGN_PFX_PASSWORD: ${{ secrets.CODESIGN_PFX_PASSWORD }}
        run: |
          $ErrorActionPreference = 'Stop'
          Write-Host "Building installer for version ${{ steps.resolve_tag.outputs.version }}..."
          & ".\INSTALLER_BUILDER.ps1" -AutoFix -Verbose
          if ($LASTEXITCODE -ne 0) {
            Write-Error "Installer build failed"
            exit 1
          }
          Write-Host "Installer build completed successfully"

      - name: Verify installer exists
        id: verify_installer
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $tag = "${{ steps.resolve_tag.outputs.tag }}"
          $version = "${{ steps.resolve_tag.outputs.version }}"

          Write-Host "=== Installer Search Debug Info ==="
          Write-Host "Tag: $tag"
          Write-Host "Version: $version"
          Write-Host "Current directory: $(Get-Location)"
          Write-Host ""

          # Show what actually exists in dist/
          Write-Host "Contents of dist/ directory:"
          if (Test-Path "dist") {
            Get-ChildItem "dist" -Filter "*.exe" | ForEach-Object {
              Write-Host "  - $($_.Name) ($([math]::Round($_.Length/1MB, 2)) MB)"
            }
          } else {
            Write-Host "  dist/ directory does not exist!"
          }
          Write-Host ""

          # Search patterns in priority order
          $installers = @(
            "dist\SMS_Installer_${version}.exe",
            "dist\SMS_Installer_${tag}.exe",
            "dist\SMS_Installer.exe",
            "SMS_Installer_${version}.exe",
            "SMS_Installer_${tag}.exe",
            "SMS_Installer.exe"
          )

          Write-Host "Searching for installer in these locations:"
          $installers | ForEach-Object { Write-Host "  - $_" }
          Write-Host ""

          $found = $false
          foreach ($path in $installers) {
            if (Test-Path $path) {
              Write-Host "✓ Found installer: $path"
              echo "path=$path" >> $env:GITHUB_OUTPUT
              $found = $true
              break
            }
          }

          if (-not $found) {
            Write-Host ""
            Write-Host "=== Recursive Search for SMS_Installer*.exe ==="
            Get-ChildItem -Path "." -Recurse -Filter "SMS_Installer*.exe" -ErrorAction SilentlyContinue | ForEach-Object {
              Write-Host "  Found: $($_.FullName)"
            }
            Write-Error "Installer not found in any expected location"
            exit 1
          }

      - name: Calculate SHA256 hash
        id: hash
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $installer = "${{ steps.verify_installer.outputs.path }}"

          if (-not (Test-Path $installer)) {
            Write-Error "Installer not found at: $installer"
            exit 1
          }

          $hash = (Get-FileHash $installer -Algorithm SHA256).Hash
          $fileSize = (Get-Item $installer).Length
          $fileSizeMB = [math]::Round($fileSize / 1MB, 2)
          echo "sha256=$hash" >> $env:GITHUB_OUTPUT
          echo "size=$fileSizeMB" >> $env:GITHUB_OUTPUT
          echo "path=$installer" >> $env:GITHUB_OUTPUT
          Write-Host "File: $installer"
          Write-Host "Size: $fileSizeMB MB"
          Write-Host "SHA256: $hash"

      - name: Validate installer payload size (guardrail)
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $installerPath = "${{ steps.hash.outputs.path }}"
          if (-not (Test-Path $installerPath)) {
            Write-Error "Installer path not found for payload validation: $installerPath"
            exit 1
          }

          $sizeBytes = (Get-Item $installerPath).Length
          $sizeMB = [math]::Round($sizeBytes / 1MB, 2)
          $minSizeBytes = 20000000  # 20 MB minimum expected payload size

          Write-Host "Installer size bytes: $sizeBytes"
          Write-Host "Installer size MB: $sizeMB"
          Write-Host "Minimum expected bytes: $minSizeBytes"

          if ($sizeBytes -lt $minSizeBytes) {
            Write-Error "Installer payload is unexpectedly small ($sizeMB MB). Blocking release asset overwrite to prevent publishing a broken installer."
            exit 1
          }

          Write-Host "✓ Installer payload size check passed"

      - name: Upload installer to release
        if: steps.hash.outputs.path != ''
        shell: pwsh
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          $ErrorActionPreference = 'Stop'
          $installerPath = "${{ steps.hash.outputs.path }}"
          $tag = "${{ steps.resolve_tag.outputs.tag }}"
          $version = "${{ steps.resolve_tag.outputs.version }}"
          $assetName = "SMS_Installer_${version}.exe"
          $repo = "${{ github.repository }}"
          $localHash = (Get-FileHash $installerPath -Algorithm SHA256).Hash.ToLowerInvariant()
          $localDigest = "sha256:$localHash"

          Write-Host "Uploading $assetName to release..."
          Write-Host "Tag: $tag"
          Write-Host "Installer path: $installerPath"
          Write-Host "Asset name: $assetName"
          Write-Host "Local digest: $localDigest"

          try {
            $release = gh release view $tag --repo $repo --json assets | ConvertFrom-Json
            $existing = $release.assets | Where-Object { $_.name -eq $assetName } | Select-Object -First 1

            if ($existing) {
              Write-Host "Existing asset detected: $($existing.name) (digest: $($existing.digest))"
              if ($existing.digest -eq $localDigest) {
                Write-Host "✓ Release installer already up-to-date; skipping upload"
                exit 0
              }

              Write-Host "Digest differs; replacing existing asset safely (delete + upload)"
              gh release delete-asset $tag $assetName --yes --repo $repo
            }

            gh release upload $tag "$installerPath#$assetName" --repo $repo
            Write-Host "✓ Successfully uploaded installer to release $tag (digest: $localDigest)"
          } catch {
            Write-Error "Failed to upload installer to release: $($_.Exception.Message)"
            exit 1
          }

      - name: Create release summary
        shell: pwsh
        run: |
          $tag = "${{ steps.resolve_tag.outputs.tag }}"
          $version = "${{ steps.resolve_tag.outputs.version }}"
          $sha256 = "${{ steps.hash.outputs.sha256 }}"
          $size = "${{ steps.hash.outputs.size }}"

          $summary = @"
          ## Release $tag - Installer Built

          **Installer**: SMS_Installer_${version}.exe
          **Version**: ${version}
          **Size**: ${size} MB
          **SHA256**: ${sha256}

          ### Verify Installer Integrity

          PowerShell:
          \`\`\`powershell
          (Get-FileHash 'SMS_Installer_${version}.exe' -Algorithm SHA256).Hash
          \`\`\`

          Expected SHA256:
          \`${sha256}\`

          The installer is available as a release asset.
          "@

          Add-Content -Path $env:GITHUB_STEP_SUMMARY -Value $summary

      - name: Post success notification
        if: success()
        run: |
          Write-Host "✓ Release workflow completed successfully"
          Write-Host "  - Tag: ${{ steps.resolve_tag.outputs.tag }}"
          Write-Host "  - Version: ${{ steps.resolve_tag.outputs.version }}"
          Write-Host "  - Installer: SMS_Installer_${{ steps.resolve_tag.outputs.version }}.exe"
          Write-Host "  - Size: ${{ steps.hash.outputs.size }} MB"
          Write-Host "  - SHA256: ${{ steps.hash.outputs.sha256 }}"
        shell: pwsh

  notify-failure:
    runs-on: ubuntu-latest
    needs: release-installer
    if: failure()
    name: Release Failure Notification

    steps:
      - name: Notify failure
        run: |
          echo "❌ Release workflow failed - check logs for details"
          echo "Tag: ${{ needs.release-installer.outputs.tag }}"
