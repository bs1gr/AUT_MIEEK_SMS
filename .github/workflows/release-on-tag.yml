
name: Create GitHub Release on tag

on:
  push:
    tags:
      - 'v1.*.*'
  workflow_dispatch:
    inputs:
      tag:
        description: 'Release tag (e.g., v1.6.0)'
        required: true
        type: string

jobs:
  create-release:
    runs-on: ubuntu-latest
    outputs:
      tag: ${{ steps.get_tag.outputs.tag_name }}
      release_created: ${{ steps.create_release.outputs.created }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get tag name
        id: get_tag
        run: |
          TAG_NAME=""
          if [ -n "${{ inputs.tag }}" ]; then
            TAG_NAME="${{ inputs.tag }}"
          else
            TAG_NAME="${{ github.ref_name }}"
          fi
          TRIMMED_TAG=$(echo "$TAG_NAME" | xargs)
          echo "tag_name=$TRIMMED_TAG" >> $GITHUB_OUTPUT
          echo "Debug: tag_name=$TRIMMED_TAG"

      - name: Validate release tag policy
        run: |
          set -euo pipefail
          TAG="${{ steps.get_tag.outputs.tag_name }}"
          echo "Validating tag: $TAG"

          if [[ ! "$TAG" =~ ^v1\.[0-9]+\.[0-9]+$ ]]; then
            echo "❌ Invalid release tag format: '$TAG'"
            echo "Required format: v1.MAJOR.MINOR (e.g., v1.18.1)"
            exit 1
          fi

          if [[ "${{ github.event_name }}" == "push" ]]; then
            if [[ "$TAG" != "${{ github.ref_name }}" ]]; then
              echo "❌ Tag mismatch: resolved '$TAG' but push ref is '${{ github.ref_name }}'"
              exit 1
            fi
          fi

          # Treat old tag workflows as immutable legacy.
          # Manual dispatch is allowed only for the current VERSION tag on corrected lineage (main).
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            if [[ ! -f VERSION ]]; then
              echo "❌ VERSION file not found on default branch checkout"
              exit 1
            fi

            CURRENT_VERSION_RAW="$(tr -d '[:space:]' < VERSION)"
            CURRENT_TAG="v${CURRENT_VERSION_RAW#v}"

            if [[ "$TAG" != "$CURRENT_TAG" ]]; then
              echo "❌ Legacy tag dispatch blocked: '$TAG'"
              echo "Manual dispatch is restricted to current lineage tag '$CURRENT_TAG'."
              echo "Old tags are immutable legacy and must not be re-released/edited via workflow dispatch."
              exit 1
            fi
          fi

          if ! git rev-parse -q --verify "refs/tags/$TAG" >/dev/null; then
            echo "❌ Tag '$TAG' does not exist in repository refs"
            exit 1
          fi

          # Ensure release tags come from the default branch history.
          # This prevents manual dispatch from publishing artifacts for off-branch tags.
          # Fetch full remote branch refs to avoid missing/dangling origin/* tracking refs.
          git fetch --no-tags --prune origin "+refs/heads/*:refs/remotes/origin/*"

          DEFAULT_BRANCH=$(git symbolic-ref --short refs/remotes/origin/HEAD 2>/dev/null | sed 's#^origin/##')
          if [[ -z "$DEFAULT_BRANCH" ]]; then
            DEFAULT_BRANCH="main"
          fi

          TARGET_REF="refs/remotes/origin/${DEFAULT_BRANCH}"
          if ! git rev-parse -q --verify "$TARGET_REF" >/dev/null; then
            echo "❌ Default branch ref '$TARGET_REF' was not found after fetch"
            exit 1
          fi

          if ! git merge-base --is-ancestor "refs/tags/$TAG" "$TARGET_REF"; then
            echo "❌ Tag '$TAG' is not reachable from $TARGET_REF"
            echo "Only default-branch tags are allowed for release dispatch."
            exit 1
          fi

          echo "✅ Tag policy validation passed"

      - name: Prepare release body
        id: prepare
        run: |
          TAG=$(echo "${{ steps.get_tag.outputs.tag_name }}" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
          echo "Debug: TAG after trim = '${TAG}'"
          NOTES_FILE=".github/RELEASE_NOTES_${TAG}.md"
          if [ -f "$NOTES_FILE" ]; then
            BODY=$(cat "$NOTES_FILE")
          else
            BODY="Release ${TAG}"
          fi
          # Encode body as base64 to safely pass through GitHub Actions
          BODY_B64=$(echo -n "$BODY" | base64 -w 0)
          echo "body_b64=${BODY_B64}" >> $GITHUB_OUTPUT

      - name: Create release (or update if exists)
        id: create_release
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const tag = '${{ steps.get_tag.outputs.tag_name }}';
            // Decode base64 body
            const body = Buffer.from('${{ steps.prepare.outputs.body_b64 }}', 'base64').toString('utf-8');
            try {
              // Try to fetch existing release
              const release = await github.rest.repos.getReleaseByTag({
                owner: context.repo.owner,
                repo: context.repo.repo,
                tag: tag,
              });
              console.log(`Release ${tag} already exists (ID: ${release.data.id}). Updating body...`);
              // Update the existing release
              await github.rest.repos.updateRelease({
                owner: context.repo.owner,
                repo: context.repo.repo,
                release_id: release.data.id,
                body: body,
              });
              core.setOutput('created', 'false');
              core.setOutput('release_id', release.data.id);
            } catch (error) {
              if (error.status === 404) {
                // Release doesn't exist, create it
                console.log(`Release ${tag} not found. Creating...`);
                const newRelease = await github.rest.repos.createRelease({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  tag_name: tag,
                  name: tag,
                  body: body,
                  draft: false,
                  prerelease: false,
                });
                core.setOutput('created', 'true');
                core.setOutput('release_id', newRelease.data.id);
              } else {
                throw error;
              }
            }

  # Trigger the installer build workflow
  trigger-installer-build:
    runs-on: ubuntu-latest
    needs: create-release
    steps:
      - name: Trigger Release Installer Workflow
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const tag = '${{ needs.create-release.outputs.tag }}';
            console.log(`Triggering installer build workflow for tag: ${tag}`);

            try {
              await github.rest.actions.createWorkflowDispatch({
                owner: context.repo.owner,
                repo: context.repo.repo,
                workflow_id: 'release-installer-with-sha.yml',
                ref: tag,
                inputs: {
                  tag: tag
                }
              });
              console.log(`✓ Installer build workflow dispatched for ${tag}`);
            } catch (error) {
              core.setFailed(`Failed to dispatch installer workflow: ${error.message}`);
              throw error;
            }

  # NOTE:
  # CI/CD pipeline dispatch was intentionally removed from this workflow.
  # Rationale: dispatching ci-cd-pipeline.yml on tag refs can execute stale
  # workflow logic from historical tags and reintroduce polluted release assets.
  # Release asset mutation is now installer-workflow-only by policy.
