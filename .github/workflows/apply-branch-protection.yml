name: Apply branch protection (admin)

on:
  workflow_dispatch:
    inputs:
      branch:
        description: 'Branch to protect'
        required: false
        default: 'main'
      contexts:
        description: 'Comma-separated required check names (e.g. Import checker,Require operator approval for operator scripts,CI)'
        required: false
        default: 'Import checker,Require operator approval for operator scripts,CI'

jobs:
  apply-protection:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Apply branch protection via octokit
        uses: actions/github-script@v6
        env:
          ADMIN_PAT: ${{ secrets.ADMIN_GH_PAT }}
        with:
          # Use ADMIN_GH_PAT from env if available, otherwise fall back to GITHUB_TOKEN
          # ADMIN_GH_PAT should be a classic personal access token with `repo` scope.
          github-token: ${{ env.ADMIN_PAT != '' && env.ADMIN_PAT || secrets.GITHUB_TOKEN }}
          script: |
            // Access workflow inputs from context payload
            // Note: core, github, context are already available in github-script action
            const payloadInputs = context.payload.inputs || {};

            // Defaults (ensure consistency when run via CLI/API without inputs)
            const defaultContexts = 'Import checker,Require operator approval for operator scripts,CI';

            const inputs = payloadInputs.contexts || defaultContexts;
            const contexts = inputs.split(',').map(s => s.trim()).filter(Boolean);
            const branch = payloadInputs.branch || context.ref.replace('refs/heads/', '') || 'main';
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            core.info(`Applying branch protection to ${owner}/${repo}@${branch} with checks: ${contexts.join(', ')}`);

            const params = {
              owner,
              repo,
              branch,
              required_status_checks: {
                strict: true,
                contexts: contexts
              },
              enforce_admins: true,
              required_pull_request_reviews: {
                dismiss_stale_reviews: true,
                require_code_owner_reviews: true,
                required_approving_review_count: 1
              },
              restrictions: null
            };

            try {
              await github.rest.repos.updateBranchProtection(params);
              core.info('Branch protection applied successfully.');
            } catch (err) {
              if (err.status === 403) {
                core.setFailed('Permission denied (403). Ensure GITHUB_TOKEN has admin permissions or set ADMIN_GH_PAT secret with repo scope. Error: ' + err.message);
              } else {
                core.setFailed('Failed to apply branch protection: ' + err.message);
              }
            }
